C51 COMPILER V9.53.0.0   EFM8LB12_PORT                                                     10/09/2019 13:50:20 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE EFM8LB12_PORT
OBJECT MODULE PLACED IN .\src\Efm8lb12_port.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v3\developer\toolchains\keil_8051\9.53\BIN\C51.exe D:\Work Project\
                    -SingleChipWorkSpaveNew\C51_UBOOT\src\Efm8lb12_port.c OMF2 LARGE DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY
                    -(3) OPTIMIZE(9,SPEED) DEFINE(NDEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(D:/Work Project/SingleChipWorkSpaveNew/C51_UB
                    -OOT/inc;D:/Work Project/SingleChipWorkSpaveNew/C51_UBOOT/mcu_sal_lib;C:/SiliconLabs/SimplicityStudio/v3/developer/sdks/s
                    -i8051/v3//Device/shared/si8051Base;C:/SiliconLabs/SimplicityStudio/v3/developer/sdks/si8051/v3//Device/EFM8LB1;C:/Silico
                    -nLabs/SimplicityStudio/v3/developer/sdks/si8051/v3//Device/EFM8LB1/inc;C:/SiliconLabs/SimplicityStudio/v3/developer/sdks
                    -/si8051/v3//Lib/efm8_assert;C:/SiliconLabs/SimplicityStudio/v3/developer/sdks/si8051/v3//Device/EFM8LB1/peripheral_drive
                    -r/inc) REGFILE(C51_UBOOT.ORC) PRINT(.\src\Efm8lb12_port.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\Efm8lb12_po
                    -rt.OBJ)

line level    source

   1          #include "Efm8lb12_port.h"
   2          #include "mcu_sal.h"
   3          
   4          static void port0_init();
   5          static void port1_init();
   6          static void port2_init();
   7          static void port3_init();
   8          static void port_crossbar_xbr0();
   9          static void port_crossbar_xbr1();
  10          static void port_crossbar_xbr2();
  11          
  12          volatile bool intl_flag = false;
  13          
  14          void port_match_init()
  15          {
  16   1              uint8_t SFRPAGE_SAVE = SFRPAGE;
  17   1      
  18   1              SFRPAGE   = 0x10;
  19   1              EIP1     &= ~(EIP1_PMAT__HIGH);         //set port match interrupt the lowest pri
  20   1              EIP1H    &= ~(EIP1H_PHMAT__HIGH);
  21   1              EIE1     &= ~EIE1_EMAT__ENABLED;    //disable interrupt requests generated by a Port Match
  22   1              SFRPAGE   = SFRPAGE_SAVE;
  23   1      }
  24          
  25          void port_match_all_interrupt_enable(uint8_t enable)
  26          {
  27   1              uint8_t SFRPAGE_SAVE = SFRPAGE;
  28   1      
  29   1              SFRPAGE  = PG2_PAGE;
  30   1      
  31   1              if (enable)
  32   1              {
  33   2                      EIE1  |= EIE1_EMAT__ENABLED;    //Enable interrupt requests generated by a Port Match
  34   2              }
  35   1              else
  36   1              {
  37   2                      EIE1  &= ~EIE1_EMAT__BMASK;     //Disable interrupt requests generated by a Port Match
  38   2              }
  39   1      
  40   1              SFRPAGE = SFRPAGE_SAVE;
  41   1              return;
  42   1      }
  43          
  44          void port_init()
  45          {
  46   1              port_crossbar_xbr2();
  47   1              port0_init();
  48   1              port1_init();
C51 COMPILER V9.53.0.0   EFM8LB12_PORT                                                     10/09/2019 13:50:20 PAGE 2   

  49   1              port2_init();
  50   1              port3_init();
  51   1              port_crossbar_xbr0();
  52   1              port_crossbar_xbr1();
  53   1      }
  54          
  55          void port_mido_output(uint8_t mod)
  56          {
  57   1              if(mod == TYPE_MDC)
  58   1              {
  59   2                      P1MDOUT |= P1MDOUT_B2__PUSH_PULL;
  60   2              }
  61   1              else if (mod == TYPE_MDIO)
  62   1              {
  63   2                      P1MDOUT |= P1MDOUT_B3__PUSH_PULL;
  64   2              }
  65   1      }
  66          
  67          void port_mido_input(uint8_t mod)
  68          {
  69   1              if(mod == TYPE_MDC)
  70   1              {
  71   2                      P1 |= P1_B2__HIGH;
  72   2                      P1MDOUT &= ~P1MDOUT_B2__PUSH_PULL;
  73   2              }
  74   1              else if (mod == TYPE_MDIO)
  75   1              {
  76   2                      P1 |= P1_B3__HIGH;
  77   2                      P1MDOUT &= ~P1MDOUT_B3__PUSH_PULL;
  78   2              }
  79   1      }
  80          
  81          static void port_crossbar_xbr0()
  82          {
  83   1              uint8_t SFRPAGE_SAVE = SFRPAGE;
  84   1      
  85   1              SFRPAGE = 0x0;
  86   1      
  87   1              XBR0 = XBR0_URT0E__DISABLED | XBR0_SPI0E__DISABLED  //disable UART0 I/O
  88   1                       | XBR0_SMB0E__DISABLED | XBR0_CP0E__DISABLED   //disable SMB0 I/O
  89   1                       | XBR0_SMB0E__DISABLED | XBR0_CP0E__DISABLED
  90   1                       | XBR0_CP0AE__DISABLED | XBR0_CP1E__DISABLED
  91   1                       | XBR0_CP1AE__DISABLED | XBR0_SYSCKE__DISABLED;
  92   1      
  93   1              SFRPAGE = SFRPAGE_SAVE;
  94   1      }
  95          
  96          static void port_crossbar_xbr2()
  97          {
  98   1              uint8_t SFRPAGE_SAVE = SFRPAGE;
  99   1      
 100   1              SFRPAGE = 0x0;
 101   1      
 102   1              XBR2 = XBR2_URT1E__DISABLED                     //disable UART1 I/O
 103   1                      | XBR2_URT1RTSE__DISABLED                       //disable UART1 RTS Output
 104   1                      | XBR2_URT1CTSE__DISABLED                       //disable UART1 CTS Input
 105   1                      | XBR2_XBARE__ENABLED                           //Crossbar Enable
 106   1                      | XBR2_WEAKPUD__PULL_UPS_ENABLED;  //Weak Pullups enable
 107   1      
 108   1              SFRPAGE = SFRPAGE_SAVE;
 109   1      }
 110          
 111          static void port_crossbar_xbr1()
C51 COMPILER V9.53.0.0   EFM8LB12_PORT                                                     10/09/2019 13:50:20 PAGE 3   

 112          {
 113   1              uint8_t SFRPAGE_SAVE = SFRPAGE;
 114   1      
 115   1              SFRPAGE = 0x0;
 116   1      
 117   1              XBR1 = XBR1_PCA0ME__DISABLED  //disable PCA Module I/O
 118   1                      | XBR1_ECIE__DISABLED     //disable PCA0 External Counter Input
 119   1                      | XBR1_T0E__DISABLED      //disable T0
 120   1                      | XBR1_T1E__DISABLED      //disable T1
 121   1                      | XBR1_T2E__DISABLED;     //disable T2
 122   1      
 123   1              SFRPAGE = SFRPAGE_SAVE;
 124   1      }
 125          
 126          static void port0_init()
 127          {
 128   1              uint8_t SFRPAGE_SAVE = SFRPAGE;
 129   1      
 130   1              SFRPAGE = 0x0;
 131   1              //1.set port default value
 132   1              P0 = P0_B0__HIGH | P0_B1__HIGH | P0_B2__HIGH | P0_B3__HIGH | P0_B4__HIGH | P0_B5__HIGH | P0_B6__HIGH | P0
             -_B7__HIGH;
 133   1      
 134   1              P0MDIN = P0MDIN_B0__DIGITAL
 135   1                              | P0MDIN_B1__DIGITAL    | P0MDIN_B2__DIGITAL  //set p0.1 ~ p0.2  analog mode is used for modprs pin and mo
             -dsel pin
 136   1                              | P0MDIN_B3__DIGITAL    //set p0.3 digital mode is used for reset pin
 137   1                              | P0MDIN_B4__DIGITAL | P0MDIN_B5__DIGITAL
 138   1                              | P0MDIN_B6__DIGITAL    //set p0.6  analog mode is used for lpmode pin
 139   1                              | P0MDIN_B7__DIGITAL;   //set p0.7  digital mode is used for reset_auto pin
 140   1      
 141   1              //3. Select the output mode (open-drain or push-pull) for all port pins, using the Port Output Mode regis
             -ter (PnMDOUT).
 142   1              P0MDOUT = P0MDOUT_B0__OPEN_DRAIN
 143   1                              | P0MDOUT_B1__OPEN_DRAIN     //because p0.1 is input pin,so set p0.1 default value(open drain mode)  is
             - used for modprs
 144   1                              | P0MDOUT_B2__OPEN_DRAIN             //because p0.2 is input pin,so set p0.2 default value(open drain mode)  i
             -s used for modsell
 145   1                              | P0MDOUT_B3__OPEN_DRAIN     //because p0.3 is input pin,so set p0.3 default value(open drain mode)  is
             - used for reset pin
 146   1                              | P0MDOUT_B4__OPEN_DRAIN | P0MDOUT_B5__OPEN_DRAIN
 147   1                              | P0MDOUT_B6__OPEN_DRAIN     //because p0.6 is input pin,so set p0.6 default value(open drain mode)  is
             - used for lpmode pin
 148   1                              | P0MDOUT_B7__OPEN_DRAIN;     //set p0.7 push pull is used for reset_auto pin,because there is Level co
             -nflict ,so modify OPEN_DRAIN
 149   1      
 150   1              //4. Select any pins to be skipped by the I/O crossbar using the Port Skip registers (PnSKIP).
 151   1              P0SKIP = P0SKIP_B0__SKIPPED   //because P1.2 and p1.3 are used to Smbus,so P0.0 ~ P0.7 must be skipped
 152   1                              | P0SKIP_B1__SKIPPED| P0SKIP_B2__SKIPPED
 153   1                              | P0SKIP_B3__SKIPPED
 154   1                              | P0SKIP_B4__NOT_SKIPPED | P0SKIP_B5__NOT_SKIPPED
 155   1                              | P0SKIP_B6__SKIPPED
 156   1                              | P0SKIP_B7__SKIPPED;
 157   1      
 158   1              //5. set p0MASK
 159   1              P0MASK = P0MASK_B0__IGNORED | P0MASK_B1__IGNORED | P0MASK_B2__IGNORED
 160   1                              | P0MASK_B3__IGNORED | P0MASK_B4__IGNORED | P0MASK_B5__IGNORED
 161   1                              | P0MASK_B6__IGNORED | P0MASK_B7__IGNORED;
 162   1      
 163   1              //6. set P0MAT
 164   1              P0MAT = P0MAT_B0__HIGH | P0MAT_B1__HIGH | P0MAT_B2__HIGH | P0MAT_B3__HIGH | P0MAT_B4__HIGH | P0MAT_B5__HI
             -GH | P0MAT_B6__HIGH | P0MAT_B7__HIGH;
 165   1      
C51 COMPILER V9.53.0.0   EFM8LB12_PORT                                                     10/09/2019 13:50:20 PAGE 4   

 166   1              SFRPAGE = SFRPAGE_SAVE;
 167   1      
 168   1      }
 169          
 170          
 171          static void port1_init()
 172          {
 173   1              uint8_t SFRPAGE_SAVE = SFRPAGE;
 174   1      
 175   1              SFRPAGE = 0x0;
 176   1              //1.set port default value
 177   1              P1 = P1_B0__HIGH | P1_B1__HIGH | P1_B2__HIGH | P1_B3__HIGH | P1_B4__LOW | P1_B5__HIGH | P1_B6__HIGH | P1_
             -B7__HIGH;
 178   1      
 179   1              //2.Select the input mode (analog or digital) for all port pins, using the Port Input Mode register (PnMD
             -IN).
 180   1              P1MDIN = P1MDIN_B0__DIGITAL
 181   1                              | P1MDIN_B1__DIGITAL
 182   1                              | P1MDIN_B2__DIGITAL
 183   1                              | P1MDIN_B3__DIGITAL
 184   1                              | P1MDIN_B4__DIGITAL
 185   1                              | P1MDIN_B5__DIGITAL
 186   1                              | P1MDIN_B6__DIGITAL
 187   1                              | P1MDIN_B7__DIGITAL;
 188   1      
 189   1              //3. Select the output mode (open-drain or push-pull) for all port pins, using the Port Output Mode regis
             -ter (PnMDOUT).
 190   1              P1MDOUT = P1MDOUT_B0__OPEN_DRAIN  //set p1.0 push pull is used for lpmode_auto pin,because there is Level
             - conflict ,so modify OPEN_DRAIN
 191   1                              | P1MDOUT_B1__OPEN_DRAIN
 192   1                              | P1MDOUT_B2__OPEN_DRAIN | P1MDOUT_B3__OPEN_DRAIN //set p1.2~ p1.3 open drain mode is used for modsel p
             -in and reset pin
 193   1                              | P1MDOUT_B4__PUSH_PULL | P1MDOUT_B5__PUSH_PULL  | P1MDOUT_B6__OPEN_DRAIN       | P1MDOUT_B7__OPEN_DRAIN;
 194   1      
 195   1              //4. Select any pins to be skipped by the I/O crossbar using the Port Skip registers (PnSKIP).
 196   1              P1SKIP = P1SKIP_B0__SKIPPED
 197   1                              | P1SKIP_B1__SKIPPED                    //set p1.1 skip in order to p1.2 and p1.3 are used for i2c master mode
 198   1                              | P1SKIP_B2__NOT_SKIPPED | P1SKIP_B3__NOT_SKIPPED
 199   1                              | P1SKIP_B4__NOT_SKIPPED | P1SKIP_B5__NOT_SKIPPED| P1SKIP_B6__NOT_SKIPPED | P1SKIP_B7__NOT_SKIPPED;
 200   1      
 201   1              //5. set p1MASK
 202   1              P1MASK = P1MASK_B0__IGNORED | P1MASK_B1__IGNORED | P1MASK_B2__IGNORED
 203   1                              | P1MASK_B3__IGNORED | P1MASK_B4__IGNORED | P1MASK_B5__IGNORED
 204   1                              | P1MASK_B6__COMPARED | P1MASK_B7__IGNORED;
 205   1      
 206   1              //6. set P1MAT
 207   1              P1MAT = P1MAT_B0__HIGH | P1MAT_B1__HIGH | P1MAT_B2__HIGH | P1MAT_B3__HIGH
 208   1                              | P1MAT_B4__HIGH | P1MAT_B5__HIGH | P1MAT_B6__LOW | P1MAT_B7__HIGH;
 209   1      
 210   1              SFRPAGE = SFRPAGE_SAVE;
 211   1      }
 212          
 213          static void port2_init()
 214          {
 215   1              uint8_t SFRPAGE_SAVE = SFRPAGE;
 216   1      
 217   1              SFRPAGE = 0x20;
 218   1              //1.set port default value
 219   1              P2 = P2_B0__LOW | P2_B1__HIGH | P2_B2__HIGH | P2_B3__HIGH | P2_B4__HIGH | P2_B5__HIGH | P2_B6__HIGH ;
 220   1      
 221   1              //2.Select the input mode (analog or digital) for all port pins, using the Port Input Mode register (PnMD
             -IN).
 222   1              P2MDIN = P2MDIN_B0__DIGITAL | P2MDIN_B1__DIGITAL | P2MDIN_B2__DIGITAL | P2MDIN_B3__DIGITAL | P2MDIN_B4__D
C51 COMPILER V9.53.0.0   EFM8LB12_PORT                                                     10/09/2019 13:50:20 PAGE 5   

             -IGITAL | P2MDIN_B5__DIGITAL | P2MDIN_B6__DIGITAL ;
 223   1              //3. Select the output mode (open-drain or push-pull) for all port pins, using the Port Output Mode regis
             -ter (PnMDOUT).
 224   1      
 225   1              P2MDOUT = P2MDOUT_B0__PUSH_PULL | P2MDOUT_B1__OPEN_DRAIN | P2MDOUT_B2__OPEN_DRAIN | P2MDOUT_B3__OPEN_DRAI
             -N | P2MDOUT_B4__OPEN_DRAIN | P2MDOUT_B5__OPEN_DRAIN | P2MDOUT_B6__OPEN_DRAIN;
 226   1      
 227   1              //4. Select any pins to be skipped by the I/O crossbar using the Port Skip registers (PnSKIP).
 228   1              P2SKIP = P2SKIP_B0__NOT_SKIPPED | P2SKIP_B1__NOT_SKIPPED
 229   1                              | P2SKIP_B2__NOT_SKIPPED | P2SKIP_B3__SKIPPED | 0x10 | 0x20 | 0x40;
 230   1      
 231   1              //5. set p2MASK
 232   1              P2MASK = P2MASK_B0__IGNORED | P2MASK_B1__IGNORED | P2MASK_B2__IGNORED
 233   1                              | P2MASK_B3__IGNORED | P2MASK_B4__IGNORED | P2MASK_B5__IGNORED
 234   1                              | P2MASK_B6__IGNORED ;
 235   1      
 236   1              //6. set P2MAT
 237   1              P2MAT = P2MAT_B0__HIGH | P2MAT_B1__HIGH | P2MAT_B2__HIGH | P2MAT_B3__HIGH | P2MAT_B4__HIGH | P2MAT_B5__HI
             -GH | P2MAT_B6__HIGH ;
 238   1      
 239   1              SFRPAGE = SFRPAGE_SAVE;
 240   1      }
 241          
 242          static void port3_init()
 243          {
 244   1              uint8_t SFRPAGE_SAVE = SFRPAGE;
 245   1      
 246   1              SFRPAGE = 0x20;
 247   1              //1.set port default value
 248   1              P3 = P3_B0__HIGH | P3_B1__HIGH | P3_B2__HIGH | P3_B3__HIGH | P3_B4__HIGH;
 249   1      
 250   1              //2.Select the input mode (analog or digital) for all port pins, using the Port Input Mode register (PnMD
             -IN).
 251   1              P3MDIN = P3MDIN_B0__DIGITAL
 252   1      
 253   1                              | P3MDIN_B1__DIGITAL
 254   1      
 255   1                              | P3MDIN_B2__DIGITAL
 256   1      
 257   1                              | P3MDIN_B3__DIGITAL
 258   1      
 259   1                              | P3MDIN_B4__DIGITAL;
 260   1      
 261   1              //3. Select the output mode (open-drain or push-pull) for all port pins, using the Port Output Mode regis
             -ter (PnMDOUT).
 262   1              P3MDOUT = P3MDOUT_B0__OPEN_DRAIN
 263   1      
 264   1                              | P3MDOUT_B1__OPEN_DRAIN
 265   1      
 266   1                              | P3MDOUT_B2__OPEN_DRAIN
 267   1      
 268   1                              | P3MDOUT_B3__OPEN_DRAIN
 269   1      
 270   1                              | P3MDOUT_B4__OPEN_DRAIN;  //because p3.4 is input pin,so set p3.4 default value(open drain mode)  is u
             -sed for intl pin
 271   1      
 272   1              //4. Select any pins to be skipped by the I/O crossbar using the Port Skip registers (PnSKIP).
 273   1      
 274   1              //p3 do't have p3SKIP registers
 275   1      
 276   1              //5. set p2MASK
 277   1              //p3 do't have P3MASK registers
 278   1      
C51 COMPILER V9.53.0.0   EFM8LB12_PORT                                                     10/09/2019 13:50:20 PAGE 6   

 279   1              //6. set P2MAT
 280   1              //p3 do't have P3MAT registers
 281   1              SFRPAGE = SFRPAGE_SAVE;
 282   1      
 283   1      }
 284          
 285          static void port_match_reverse(uint8_t port, uint8_t pin)
 286          {
 287   1              uint8_t SFRPAGE_SAVE = SFRPAGE;
 288   1      
 289   1              SFRPAGE  = PG3_PAGE;
 290   1      
 291   1              if(port == 0)
 292   1              {
 293   2                      if (P0MAT & (1 << pin))
 294   2                              P0MAT &= ~(1 << pin);
 295   2                      else
 296   2                              P0MAT |= (1 << pin);
 297   2              }
 298   1              else if(port == 1)
 299   1              {
 300   2                      if (P1MAT & (1 << pin))
 301   2                              P1MAT &= ~(1 << pin);
 302   2                      else
 303   2                              P1MAT |= (1 << pin);
 304   2              }
 305   1              else if(port == 2)
 306   1              {
 307   2                      if (P1MAT & (1 << pin))
 308   2                              P1MAT &= ~(1 << pin);
 309   2                      else
 310   2                              P1MAT |= (1 << pin);
 311   2              }
 312   1              SFRPAGE = SFRPAGE_SAVE;
 313   1              return;
 314   1      }
 315          
 316          SI_INTERRUPT (PMATCH_ISR, PMATCH_IRQn)
 317          {
 318   1              intl_flag = true;
 319   1              port_match_reverse(1,6);
 320   1      }
 321          
 322          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    452    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
