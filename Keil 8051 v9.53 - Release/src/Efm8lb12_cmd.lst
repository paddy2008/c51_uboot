C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE EFM8LB12_CMD
OBJECT MODULE PLACED IN .\src\Efm8lb12_cmd.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v3\developer\toolchains\keil_8051\9.53\BIN\C51.exe D:\Work Project\
                    -SingleChipWorkSpaveNew\C51_UBOOT\src\Efm8lb12_cmd.c OMF2 LARGE DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(
                    -3) OPTIMIZE(9,SPEED) DEFINE(NDEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(D:/Work Project/SingleChipWorkSpaveNew/C51_UBO
                    -OT/inc;D:/Work Project/SingleChipWorkSpaveNew/C51_UBOOT/mcu_sal_lib;C:/SiliconLabs/SimplicityStudio/v3/developer/sdks/si
                    -8051/v3//Device/shared/si8051Base;C:/SiliconLabs/SimplicityStudio/v3/developer/sdks/si8051/v3//Device/EFM8LB1;C:/Silicon
                    -Labs/SimplicityStudio/v3/developer/sdks/si8051/v3//Device/EFM8LB1/inc;C:/SiliconLabs/SimplicityStudio/v3/developer/sdks/
                    -si8051/v3//Lib/efm8_assert;C:/SiliconLabs/SimplicityStudio/v3/developer/sdks/si8051/v3//Device/EFM8LB1/peripheral_driver
                    -/inc) REGFILE(C51_UBOOT.ORC) PRINT(.\src\Efm8lb12_cmd.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\Efm8lb12_cmd.
                    -OBJ)

line level    source

   1          #include "mcu_sal.h"
   2          #include "Efm8lb12_cmd.h"
   3          #include "Efm8lb12_port.h"
   4          #include "Efm8lb12_qsfp28.h"
   5          
   6          TIMER_STRUCT_T prbs_code_timer;
   7          TIMER_STRUCT_T rssi_poll_timer;
   8          TIMER_STRUCT_T intl_trigger_timer;
   9          
  10          /************************************************function declaration*************************************
             -***********************/
  11          #if 0
              uint8_t smb_read_multi_byte_test(uint8_t BaseAddr,uint16_t OffsetAddr,uint8_t *Pdata,uint16_t Length)
              {
                      uint32_t i = 0;
              
                      for (i = 0;SMB_BUSY;i++); // Wait for SMBus to be free.
                      SMB_BUSY = 1;                       // Claim SMBus (set to busy)
              
                      // Set SMBus ISR parameters
                      TARGET = BaseAddr;                      // Set target slave address
                      SMB_RW = WRITE;                     // A random read starts as a write
                                                                                          // then changes to a read after
                                                                                          // the repeated start is sent. The
                                                                                          // ISR handles this switchover if
                                                                                          // the <SMB_RANDOMREAD> bit is set.
                      SMB_SENDWORDADDR = 1;               // Send Word Address after Slave Address
                      SMB_RANDOMREAD = 1;                 // Send a START after the word address
                      SMB_ACKPOLL = 0;                    // Enable Acknowledge Polling
              
                      if(BaseAddr == 0xa8 || BaseAddr == 0xb8 || BaseAddr == 0x24) //12bit offsetaddr
                  {
                      WORD_ADDR_HIGH = (OffsetAddr & 0xFF00) >> 8;
                      WORD_ADDR_LOW = OffsetAddr & 0xFF;
                      gSingleByteOffsetAddr = false;
                  }
                  else
                  {
                      WORD_ADDR_LOW = OffsetAddr & 0xFF;
                      gSingleByteOffsetAddr = true;
                  }
              
                      // Set the the incoming data pointer
                      pSMB_DATA_IN = Pdata;
                      SMB_DATA_LEN = Length;                // Specify to ISR that the next transferwill contain <len> data byt
             -es
              
                      // Initiate SMBus Transfer
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 2   

                      SMB0CN0_STA = 1;
              
                      /*
                      for(i = 0;SMB_BUSY;i++)                       // Wait until data is read
                      {
                              if (i >= 0xfffff)
                              {
                                      uart_printf("\r\nRead multi type timeout,reset smbus");
                                      SMB0CF &= ~0x80;           // Reset communication
                                      SMB0CF |= 0x80;
                                      SMB0CN0_STA = 0;
                                      SMB0CN0_STO = 0;
                                      SMB0CN0_ACK = 0;
                                      SMB_BUSY = 0;              // Free SMBus
                                      SMB_ACKPOLL = 0;
                                      return RET_FAILED;
                              }
                      }
                      */
              
                      return RET_OK;
              }
              
              #endif
  71          
  72          static RETURN_VALUE_TYPE prvDispEepConfig(PARAM_INFO_T  *param)//eep [init|show|regset|erase] devaddr offs
             -etaddr value
  73          {
  74   1              uint8_t ret = RET_OK;
  75   1      
  76   1              if(!strcmp(param->argv[1],"init"))
  77   1              {
  78   2                      ret = qsfp28_eep_handle(EEP_INIT, 0, 0, 0);
  79   2              }
  80   1              else if(!strcmp(param->argv[1],"show"))
  81   1              {
  82   2                      ret = qsfp28_eep_handle(EEP_SHOW, 0, 0, 0);
  83   2              }
  84   1              else if(!strcmp(param->argv[1],"regset"))
  85   1              {
  86   2                      SAVE_REG_T save_reg;
  87   2                      save_reg.devAddr    = com_str_to_int16(param->argv[2]);
  88   2                      save_reg.offsetAddr = com_str_to_int16(param->argv[3]);
  89   2                      save_reg.value      = com_str_to_int16(param->argv[4]);
  90   2                      ret = qsfp28_eep_handle(EEP_SAVE, save_reg.devAddr, save_reg.offsetAddr, save_reg.value);
  91   2              }
  92   1              else if(!strcmp(param->argv[1],"erase"))
  93   1              {
  94   2                      ret = qsfp28_eep_handle(EEP_ERASE, 0, 0, 0);
  95   2              }
  96   1              return ret;
  97   1      }
  98          
  99          static RETURN_VALUE_TYPE prvDispOprwConfig(PARAM_INFO_T  *param)
 100          {
 101   1              I2C_DATA_T i2c_data;
 102   1              uint8_t databuff[200] = {0};  //read 200 bytes at one time
 103   1              uint8_t result = RET_FAILED;
 104   1              uint8_t page = 0;
 105   1      
 106   1              i2c_data.devAddr        = com_str_to_int16(param->argv[1]);
 107   1              i2c_data.offsetAddr = com_str_to_int16(param->argv[2]);
 108   1              i2c_data.readData   = databuff;
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 3   

 109   1              i2c_data.writeData  = databuff;
 110   1              i2c_data.i2c_dbg_mode = false;  //false:normal i2c mode,true:dbg i2c mode
 111   1      
 112   1              if ((!strcmp(param->argv[0],"opw"))||(!strcmp(param->argv[0],"opwt")))
 113   1              {
 114   2                      i2c_data.rwType = WRITE_CMD;
 115   2              }
 116   1              else if ((!strcmp(param->argv[0],"opr"))||(!strcmp(param->argv[0],"oprt")))
 117   1              {
 118   2                      i2c_data.rwType = READ_CMD;
 119   2              }
 120   1      
 121   1              if(i2c_data.rwType == READ_CMD)
 122   1              {
 123   2                      if(param->argc < 3)
 124   2                      {
 125   3                              return RET_FAILED;
 126   3                      }
 127   2                      else if(param->argc == 3)
 128   2                      {
 129   3                              i2c_data.rwByteNum = 1;
 130   3                      }
 131   2                      else
 132   2                      {
 133   3                              i2c_data.rwByteNum = (com_str_to_int16(param->argv[3]) > 200) ? 200 : com_str_to_int16(param->argv[3]);
 134   3                      }
 135   2              }
 136   1              else if(i2c_data.rwType == WRITE_CMD)
 137   1              {
 138   2                      uint8_t i = 0, index = 0;
 139   2      
 140   2                      if(param->argc < 4)
 141   2                      {
 142   3                              return RET_FAILED;
 143   3                      }
 144   2                      else if(param->argc == 0x4)
 145   2                      {
 146   3                              i2c_data.rwByteNum = param->argc - 3;
 147   3                              index = 3;
 148   3                      }
 149   2                      else
 150   2                      {
 151   3                              i2c_data.rwByteNum = ((param->argc - 4) > 128) ? 128 : (param->argc - 4);
 152   3                              index = 4;
 153   3                      }
 154   2      
 155   2                      for(i= 0; i < i2c_data.rwByteNum;i++ )
 156   2                      {
 157   3                              databuff[i] = com_str_to_int16(param->argv[index + i]);
 158   3                      }
 159   2              }
 160   1              else
 161   1              {
 162   2                      return RET_FAILED;
 163   2              }
 164   1      
 165   1              if((strcmp(param->argv[0],"opwt")) && strcmp(param->argv[0],"oprt"))
 166   1              {
 167   2                      if(i2c_data.devAddr != I2C_DEVICE_ADDR && i2c_data.devAddr != I2C_DEVICE_ADDR1)
 168   2                      {
 169   3                              i2c_data.i2c_dbg_mode = true;
 170   3                      }
 171   2                      else
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 4   

 172   2                      {
 173   3                              i2c_master_read_byte(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, &page);
 174   3                      }
 175   2              }
 176   1      
 177   1              if(i2c_data.rwType == READ_CMD)
 178   1              {
 179   2                      if((i2c_data.i2c_dbg_mode == true) && (i2c_data.devAddr != I2C_DEVICE_ADDR))
 180   2                      {
 181   3                              result = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, SFP_PAGE_04H);
 182   3                              JUDGE_RETURN(result);
 183   3                              result = i2c_pass_through_read(i2c_data.devAddr, page, i2c_data.offsetAddr, i2c_data.readData, i2c_data
             -.rwByteNum);
 184   3                      }
 185   2                      else
 186   2                      {
 187   3                              result = i2c_master_read(i2c_data.devAddr, i2c_data.offsetAddr,  i2c_data.readData, i2c_data.rwByteNum)
             -;
 188   3                      }
 189   2              }
 190   1              else
 191   1              {
 192   2                      if(i2c_data.i2c_dbg_mode == true)
 193   2                      {
 194   3                              result = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, SFP_PAGE_04H);
 195   3                              JUDGE_RETURN(result);
 196   3                              result = i2c_pass_through_write(i2c_data.devAddr, page, i2c_data.offsetAddr, i2c_data.readData, i2c_dat
             -a.rwByteNum);
 197   3                      }
 198   2                      else
 199   2                      {
 200   3                              result = i2c_master_write(i2c_data.devAddr, i2c_data.offsetAddr, i2c_data.readData, i2c_data.rwByteNum)
             -;
 201   3                      }
 202   2              }
 203   1      
 204   1              if(result == RET_OK)
 205   1              {
 206   2                      uart_printf("\r\n The value on page (0x%bx), index(0x%x) : ",i2c_data.devAddr,i2c_data.offsetAddr);
 207   2                      while(i2c_data.rwByteNum --)
 208   2                      {
 209   3                              uart_printf(" 0x%bx",*(i2c_data.readData++));
 210   3                      }
 211   2              }
 212   1              return result;
 213   1      }
 214          
 215          
 216          static RETURN_VALUE_TYPE prvDispMdiorwConfig(PARAM_INFO_T  *param)
 217          {
 218   1              I2C_DATA_T i2c_data;
 219   1              uint16_t databuff[10] = {0};  //
 220   1              uint8_t result = RET_OK;
 221   1              uint8_t page = 0;
 222   1              uint32_t ret = 0;
 223   1      
 224   1              i2c_data.devAddr        = com_str_to_int16(param->argv[1]);  //mdior 0x3 0x5
 225   1              i2c_data.offsetAddr = com_str_to_int16(param->argv[2]);
 226   1      
 227   1              //i2c_data.readData   = databuff;
 228   1              //i2c_data.writeData  = databuff;
 229   1              i2c_data.i2c_dbg_mode = false;  //false:normal i2c mode,true:dbg i2c mode
 230   1      
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 5   

 231   1              if (!strcmp(param->argv[0],"mdiow"))
 232   1              {
 233   2                      i2c_data.rwType = WRITE_CMD;
 234   2              }
 235   1              else if (!strcmp(param->argv[0],"mdior"))
 236   1              {
 237   2                      i2c_data.rwType = READ_CMD;
 238   2              }
 239   1      
 240   1              if(i2c_data.rwType == READ_CMD)
 241   1              {
 242   2                      if(param->argc < 3)
 243   2                      {
 244   3                              return RET_FAILED;
 245   3                      }
 246   2                      else if(param->argc == 3)
 247   2                      {
 248   3                              i2c_data.rwByteNum = 1;
 249   3                      }
 250   2                      else
 251   2                      {
 252   3                              i2c_data.rwByteNum = (com_str_to_int16(param->argv[3]) > 200) ? 200 : com_str_to_int16(param->argv[3]);
 253   3                      }
 254   2              }
 255   1              else if(i2c_data.rwType == WRITE_CMD)
 256   1              {
 257   2                      uint8_t i = 0, index = 0;
 258   2      
 259   2                      if(param->argc < 4)
 260   2                      {
 261   3                              return RET_FAILED;
 262   3                      }
 263   2                      else if(param->argc == 0x4)
 264   2                      {
 265   3                              i2c_data.rwByteNum = param->argc - 3;
 266   3                              index = 3;
 267   3                      }
 268   2                      else
 269   2                      {
 270   3                              i2c_data.rwByteNum = ((param->argc - 4) > 128) ? 128 : (param->argc - 4);
 271   3                              index = 4;
 272   3                      }
 273   2      
 274   2                      for(i= 0; i < i2c_data.rwByteNum;i++ )
 275   2                      {
 276   3                              databuff[i] = com_str_to_int16(param->argv[index + i]);
 277   3                      }
 278   2              }
 279   1              else
 280   1              {
 281   2                      return RET_FAILED;
 282   2              }
 283   1      
 284   1      
 285   1              if(i2c_data.rwType == READ_CMD)
 286   1              {
 287   2                      //uint32_t reg =  i2c_data.devAddr << 16 | i2c_data.offsetAddr;
 288   2                      //ret = (uint16_t)mdio_bb_read(0x1, reg);
 289   2      
 290   2                      ret = mdio_read(0x1, i2c_data.devAddr, i2c_data.offsetAddr);
 291   2      
 292   2                      uart_printf("\r\n The value on page (0x%bx), index(0x%hx) : ",i2c_data.devAddr,i2c_data.offsetAddr);
 293   2      
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 6   

 294   2                      while(i2c_data.rwByteNum --)
 295   2                      {
 296   3                              uart_printf(" 0x%lx", ret);
 297   3                      }
 298   2              }
 299   1              else
 300   1              {
 301   2                      //uint32_t reg =  i2c_data.devAddr << 16 | i2c_data.offsetAddr;
 302   2                      //mdio_bb_write(0x1, reg, databuff[0]);
 303   2      
 304   2                      mdio_write(0x1, i2c_data.devAddr, i2c_data.offsetAddr, databuff[0]);
 305   2      
 306   2                      uart_printf("\r\n The value on page (0x%bx), index(0x%x) : ",i2c_data.devAddr,i2c_data.offsetAddr);
 307   2      
 308   2                      while(i2c_data.rwByteNum --)
 309   2                      {
 310   3                              uart_printf(" 0x%hx", databuff[0]);
 311   3                      }
 312   2              }
 313   1      
 314   1      
 315   1              return result;
 316   1      }
 317          
 318          static RETURN_VALUE_TYPE prvDispVersionConfig(PARAM_INFO_T  *param)
 319          {
 320   1              uart_printf( "\r\n MCU_TEST_BOARD-v%bu.%bu    %s.%s", VERSION_MAJOR, VERSION_MINOR, __DATE__,__TIME__);
 321   1      
 322   1              param = NULL;
 323   1              return RET_OK;
 324   1      }
 325          
 326          static RETURN_VALUE_TYPE prvDispConfigModConfig(PARAM_INFO_T  *param)
 327          {
 328   1              RETURN_VALUE_TYPE ret = RET_OK;
 329   1      
 330   1              if(!strcmp(param->argv[1],"enable"))
 331   1              {
 332   2                      ret = qsfp28_config_mod_console(true);
 333   2              }
 334   1              else
 335   1              {
 336   2                      ret = qsfp28_config_mod_console(false);
 337   2              }
 338   1              return ret;
 339   1      }
 340          
 341          static RETURN_VALUE_TYPE prvDispMsaDownloadConfig()
 342          {
 343   1              uint8_t SFRPAGE_SAVE = SFRPAGE;
 344   1      
 345   1              SFRPAGE = 0x0;
 346   1              P1MDOUT &= ~P1MDOUT_B5__PUSH_PULL ;
 347   1      
 348   1              SFRPAGE = 0x20;
 349   1              P2MDOUT &= ~P2MDOUT_B0__PUSH_PULL ;
 350   1      
 351   1              RESET  = 1;
 352   1              MODSEL = 1;
 353   1      
 354   1              SFRPAGE = SFRPAGE_SAVE;
 355   1              return RET_OK;
 356   1      }
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 7   

 357          
 358          static RETURN_VALUE_TYPE prvDispResetConfig()
 359          {
 360   1              uint8_t ret = RET_OK;
 361   1      
 362   1              ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, SFP_PAGE_04H);
 363   1              JUDGE_RETURN(ret);
 364   1              ret = i2c_master_write_byte(I2C_DEVICE_ADDR, SFP_DBG_CMD, DBG_RESET_CMD);
 365   1              return ret;
 366   1      }
 367          
 368          static RETURN_VALUE_TYPE prvDispRebootConfig()
 369          {
 370   1              uint8_t ret = RET_OK;
 371   1      
 372   1              ret = prvDispResetConfig();
 373   1              JUDGE_RETURN(ret);
 374   1              //M37046_txcdr_reset();
 375   1              //M37049_txcdr_reset();
 376   1              RSTSRC |= 0x10;                 //Writing a 1 to fourth bit forces a system reset
 377   1              return ret;
 378   1      }
 379          
 380          static RETURN_VALUE_TYPE prvDispLpmodeConfig(PARAM_INFO_T  *param)
 381          {
 382   1              uint8_t value = 0, ret = RET_OK;
 383   1      
 384   1              if (!strcmp(param->argv[0], "set"))
 385   1              {
 386   2                      value = (uint8_t)com_str_to_int16(param->argv[2]);
 387   2                      LPMODE = (value ? 1 : 0);
 388   2              }
 389   1              else if (!strcmp(param->argv[0], "get"))
 390   1              {
 391   2                      uart_printf( "\r\nlpmode is %bu",LPMODE ? 1 : 0);
 392   2              }
 393   1              else
 394   1              {
 395   2                      ret = RET_FAILED;
 396   2              }
 397   1              return ret;
 398   1      }
 399          
 400          static RETURN_VALUE_TYPE prvDispgsetResetConfig(PARAM_INFO_T  *param)
 401          {
 402   1              uint8_t value = 0, ret = RET_OK;
 403   1      
 404   1              if (!strcmp(param->argv[0], "set"))
 405   1              {
 406   2                      value = (uint8_t)com_str_to_int16(param->argv[2]);
 407   2                      RESET = (value ? 1 : 0);
 408   2                      com_delay_us(1);
 409   2                      RESET = 1;
 410   2              }
 411   1              else if (!strcmp(param->argv[0], "get"))
 412   1              {
 413   2                      uart_printf( "\r\nreset is %bu",RESET ? 1 : 0);
 414   2              }
 415   1              else
 416   1              {
 417   2                      ret = RET_FAILED;
 418   2              }
 419   1              return ret;
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 8   

 420   1      }
 421          
 422          static RETURN_VALUE_TYPE prvDispgsetResetLevelConfig(PARAM_INFO_T  *param)
 423          {
 424   1              uint8_t value = 0, ret = RET_OK;
 425   1      
 426   1              if (!strcmp(param->argv[0], "set"))
 427   1              {
 428   2                      value = (uint8_t)com_str_to_int16(param->argv[2]);
 429   2                      RESET = (value ? 1 : 0);
 430   2              }
 431   1              else if (!strcmp(param->argv[0], "get"))
 432   1              {
 433   2                      uart_printf( "\r\nreset is %bu",RESET ? 1 : 0);
 434   2              }
 435   1              else
 436   1              {
 437   2                      ret = RET_FAILED;
 438   2              }
 439   1              return ret;
 440   1      }
 441          
 442          static RETURN_VALUE_TYPE prvDispLogConfig(PARAM_INFO_T  *param)
 443          {
 444   1              DEBUG_LOG_ACTION type;
 445   1      
 446   1              if(!strcmp(param->argv[0],"clear"))
 447   1              {
 448   2                      type = CLEAR_LOG_CMD;
 449   2              }
 450   1              else if(!strcmp(param->argv[0],"enable"))
 451   1              {
 452   2                      type = ENABLE_LOG_CMD;
 453   2              }
 454   1              else if(!strcmp(param->argv[0],"disable"))
 455   1              {
 456   2                      type = DISABLE_LOG_CMD;
 457   2              }
 458   1              else if(!strcmp(param->argv[0],"read"))
 459   1              {
 460   2                      type = READ_LOG_CMD;
 461   2              }
 462   1              else
 463   1              {
 464   2                      return RET_FAILED;
 465   2              }
 466   1      
 467   1              return qsfp28_debug_log_handle(type);
 468   1      }
 469          
 470          static RETURN_VALUE_TYPE prvDispModselConfig(PARAM_INFO_T  *param)
 471          {
 472   1              uint8_t value = 0, ret = RET_OK;
 473   1      
 474   1              if (!strcmp(param->argv[0], "set"))
 475   1              {
 476   2                      value = (uint8_t)com_str_to_int16(param->argv[2]);
 477   2                      MODSEL = (value ? 1 : 0);
 478   2              }
 479   1              else if (!strcmp(param->argv[0], "get"))
 480   1              {
 481   2                      uart_printf( "\r\nmodsel is %bu",MODSEL ? 1 : 0);
 482   2              }
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 9   

 483   1              else
 484   1              {
 485   2                      ret = RET_FAILED;
 486   2              }
 487   1              return ret;
 488   1      }
 489          
 490          static RETURN_VALUE_TYPE prvDispTestModselConfig(PARAM_INFO_T  *param)
 491          {
 492   1              uint8_t value = 0, tmp[256] = {0},ret = RET_OK;
 493   1      
 494   1              if (!strcmp(param->argv[1], "modsel"))  //test modsel 0|1
 495   1              {
 496   2                      if (!strcmp(param->argv[0], "test"))  //test modsel 0|1
 497   2                      {
 498   3                              if (!strcmp(param->argv[2], "aborted"))  //test modsel aborted
 499   3                              {
 500   4                                      //smb_read_multi_byte_test(I2C_DEVICE_ADDR, 0x0, &tmp, 256); //12.5ms
 501   4                                      timer_delay_ms(6);
 502   4                                      MODSEL = 1;
 503   4      
 504   4                                      #if I2C_MASTER_MODE
                                                      i2c_master_reset();
                                              #endif
 507   4                                      com_delay_us(100);
 508   4      
 509   4                                      if(RET_OK == i2c_master_read_byte(0x16, 0x0, &value))
 510   4                                      {
 511   5                                              uart_printf( "\r\nmodsel is %bu and dvt test board 37046 reg0 = %bx",MODSEL ? 1 : 0, value);
 512   5                                      }
 513   4      
 514   4                                      MODSEL = 0;
 515   4                                      if(RET_OK == i2c_master_read_byte(I2C_DEVICE_ADDR, 0x0, &value))
 516   4                                      {
 517   5                                              uart_printf( "\r\nmodsel is %bu and qsfp28 lower page0 = %bx",MODSEL ? 1 : 0, value);
 518   5                                      }
 519   4      
 520   4                              }
 521   3                              else
 522   3                              {
 523   4                                      value = (uint8_t)com_str_to_int16(param->argv[2]);
 524   4                                      MODSEL = (value ? 1 : 0);
 525   4                                      com_delay_us(1);
 526   4                                      if(RET_OK == i2c_master_read_byte(I2C_DEVICE_ADDR, 0x0, &value))
 527   4                                      {
 528   5                                              uart_printf( "\r\nmodsel is %bu and value = %bx",MODSEL ? 1 : 0, value);
 529   5                                      }
 530   4                              }
 531   3                      }
 532   2              }
 533   1              else
 534   1              {
 535   2                      ret = RET_FAILED;
 536   2              }
 537   1              return ret;
 538   1      }
 539          
 540          static uint8_t prvDispInitConfig(PARAM_INFO_T  *param)
 541          {
 542   1              uint8_t value = 0, ret = RET_OK;
 543   1      
 544   1              param = NULL;
 545   1      
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 10  

 546   1              uart_printf( "\r\nintl is %bu",INTL ? 1 : 0);
 547   1              return ret;
 548   1      }
 549          
 550          static RETURN_VALUE_TYPE prvDispSwverConfig(PARAM_INFO_T  *param)
 551          {
 552   1              uint8_t value = 0, ret = RET_OK;
 553   1      
 554   1              if (!strcmp(param->argv[0], "get"))
 555   1              {
 556   2                      ret = qsfp28_get_mod_release_info();
 557   2              }
 558   1              return ret;
 559   1      }
 560          
 561          static RETURN_VALUE_TYPE prvDispModStatusConfig(PARAM_INFO_T  *param)
 562          {
 563   1              uint8_t value = 0, ret = RET_OK;
 564   1      
 565   1              if (!strcmp(param->argv[0], "get"))
 566   1              {
 567   2                      if(com_get_module_boot_status())
 568   2                      {
 569   3                              ret = qsfp28_get_mod_release_info();
 570   3                      }
 571   2                      else
 572   2                      {
 573   3                              ret = RET_FAILED;
 574   3                      }
 575   2              }
 576   1              else
 577   1              {
 578   2                      ret = RET_FAILED;
 579   2              }
 580   1              if(ret == RET_OK)
 581   1              {
 582   2                      uart_printf("%s","\r\nModule boot success");
 583   2              }
 584   1              else
 585   1              {
 586   2                      uart_printf("%s","\r\nModule boot error");
 587   2              }
 588   1              return ret;
 589   1      }
 590          
 591          static RETURN_VALUE_TYPE prvDispModuleConfig(PARAM_INFO_T  *param)
 592          {
 593   1              uint8_t value = 0, channel = 0, ret = RET_OK;
 594   1      
 595   1               ret = qsfp28_get_msa_lower_page_monitor();
 596   1      
 597   1               if(!strcmp(param->argv[2],"vcc"))
 598   1               {
 599   2                       ret = qsfp28_get_ddmi(DDMI_VCC, 0, DDMI_CALI_AFTER);
 600   2               }
 601   1               else if(!strcmp(param->argv[2],"temp"))
 602   1               {
 603   2                       ret = qsfp28_get_ddmi(DDMI_TEMP, 0, DDMI_CALI_AFTER);
 604   2               }
 605   1               else
 606   1               {
 607   2                       channel = (uint8_t)com_str_to_int16(param->argv[3]);
 608   2      
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 11  

 609   2                       if(!strcmp(param->argv[2],"bias"))
 610   2                       {
 611   3                               ret = qsfp28_get_ddmi(DDMI_BIAS, channel, DDMI_CALI_AFTER);
 612   3                       }
 613   2                       else if(!strcmp(param->argv[2],"txpower"))
 614   2                       {
 615   3                               ret = qsfp28_get_ddmi(DDMI_TXMON, channel, DDMI_CALI_AFTER);
 616   3                       }
 617   2                       else if(!strcmp(param->argv[2],"rxpower"))
 618   2                       {
 619   3                               ret =  qsfp28_get_ddmi(DDMI_RSSI, channel, DDMI_CALI_AFTER);
 620   3                       }
 621   2                       else
 622   2                       {
 623   3                               ret = RET_FAILED;
 624   3                       }
 625   2               }
 626   1      
 627   1               return ret;
 628   1      }
 629          
 630          static RETURN_VALUE_TYPE prvDispVendorPnConfig(PARAM_INFO_T  *param)
 631          {
 632   1              uint8_t  ret = RET_OK;
 633   1      
 634   1              if (!strcmp(param->argv[0],"set"))
 635   1              {
 636   2                      ret = smb_write_page_byte(I2C_DEVICE_ADDR, MSA_PAGE_00H, MSA_VENDOR_PN, param->argv[2], MSA_VENDOR_PN_LE
             -N);
 637   2              }
 638   1              else if (!strcmp(param->argv[0],"get"))
 639   1              {
 640   2                      ret = smb_read_page_byte(I2C_DEVICE_ADDR, MSA_PAGE_00H, MSA_VENDOR_PN, param->argv[2], MSA_VENDOR_PN_LEN
             -);
 641   2                      JUDGE_RETURN(ret);
 642   2                      uart_printf("\r\nVender_pn:%s",param->argv[2]);
 643   2              }
 644   1              else
 645   1              {
 646   2                      ret = RET_FAILED;
 647   2              }
 648   1      
 649   1              return ret;
 650   1      }
 651          
 652          static RETURN_VALUE_TYPE prvDispVendorRevConfig(PARAM_INFO_T  *param)
 653          {
 654   1              uint8_t  ret = RET_OK;
 655   1      
 656   1              if (!strcmp(param->argv[0],"set"))
 657   1              {
 658   2                      ret = smb_write_page_byte(I2C_DEVICE_ADDR, MSA_PAGE_00H, MSA_VENDOR_REV, param->argv[2], MSA_VENDOR_REV_
             -LEN);
 659   2              }
 660   1              else if (!strcmp(param->argv[0],"get"))
 661   1              {
 662   2                      ret = smb_read_page_byte(I2C_DEVICE_ADDR, MSA_PAGE_00H, MSA_VENDOR_REV, param->argv[2], MSA_VENDOR_REV_L
             -EN);
 663   2                      JUDGE_RETURN(ret);
 664   2                      uart_printf("\r\nVender_rev:%s",param->argv[2]);
 665   2              }
 666   1              else
 667   1              {
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 12  

 668   2                      ret = RET_FAILED;
 669   2              }
 670   1      
 671   1              return ret;
 672   1      }
 673          
 674          static RETURN_VALUE_TYPE prvDispVendorSnConfig(PARAM_INFO_T  *param)
 675          {
 676   1              uint8_t  ret = RET_OK;
 677   1      
 678   1              if (!strcmp(param->argv[0],"set"))
 679   1              {
 680   2                      ret = smb_write_page_byte(I2C_DEVICE_ADDR, MSA_PAGE_00H, MSA_VENDOR_SN, param->argv[2], MSA_VENDOR_SN_LE
             -N);
 681   2              }
 682   1              else if (!strcmp(param->argv[0],"get"))
 683   1              {
 684   2                      ret = smb_read_page_byte(I2C_DEVICE_ADDR, MSA_PAGE_00H, MSA_VENDOR_SN, param->argv[2], MSA_VENDOR_SN_LEN
             -);
 685   2                      JUDGE_RETURN(ret);
 686   2                      uart_printf("\r\nVender_sn:%s",param->argv[2]);
 687   2              }
 688   1              else
 689   1              {
 690   2                      ret = RET_FAILED;
 691   2              }
 692   1      
 693   1              return ret;
 694   1      }
 695          
 696          static RETURN_VALUE_TYPE prvDispDateCodeConfig(PARAM_INFO_T  *param)
 697          {
 698   1              uint8_t  ret = RET_OK;
 699   1      
 700   1              if (!strcmp(param->argv[0],"set"))
 701   1              {
 702   2                      ret = smb_write_page_byte(I2C_DEVICE_ADDR, MSA_PAGE_00H, MSA_DATA_CODE, param->argv[2], MSA_DATA_CODE_LE
             -N);
 703   2              }
 704   1              else if (!strcmp(param->argv[0],"get"))
 705   1              {
 706   2                      ret = smb_read_page_byte(I2C_DEVICE_ADDR, MSA_PAGE_00H, MSA_DATA_CODE, param->argv[2], MSA_DATA_CODE_LEN
             -);
 707   2                      JUDGE_RETURN(ret);
 708   2                      uart_printf("\r\nDate_code:%s",param->argv[2]);
 709   2              }
 710   1              else
 711   1              {
 712   2                      ret = RET_FAILED;
 713   2              }
 714   1      
 715   1              return ret;
 716   1      }
 717          
 718          static RETURN_VALUE_TYPE prvDispSuperCodeConfig(PARAM_INFO_T  *param)
 719          {
 720   1              uint8_t  ret = RET_OK;
 721   1      
 722   1              if (!strcmp(param->argv[0],"set"))
 723   1              {
 724   2                      ret = smb_write_page_byte(I2C_DEVICE_ADDR, SFP_PAGE_05H, SUPERCODE, param->argv[2], SUPERCODE_LEN);
 725   2              }
 726   1              else if (!strcmp(param->argv[0],"get"))
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 13  

 727   1              {
 728   2                      ret = smb_read_page_byte(I2C_DEVICE_ADDR, SFP_PAGE_05H, SUPERCODE, param->argv[2], SUPERCODE_LEN);
 729   2                      JUDGE_RETURN(ret);
 730   2                      uart_printf("\r\nSupercode:%s",param->argv[2]);
 731   2              }
 732   1              else
 733   1              {
 734   2                      ret = RET_FAILED;
 735   2              }
 736   1      
 737   1              return ret;
 738   1      }
 739          
 740          static RETURN_VALUE_TYPE prvDispPcbaSnConfig(PARAM_INFO_T  *param)
 741          {
 742   1              uint8_t  ret = RET_OK;
 743   1      
 744   1              if (!strcmp(param->argv[0],"set"))
 745   1              {
 746   2                      ret = smb_write_page_byte(I2C_DEVICE_ADDR, SFP_PAGE_05H, PCBA_SN, param->argv[2], PCBA_SN_LEN);
 747   2              }
 748   1              else if (!strcmp(param->argv[0],"get"))
 749   1              {
 750   2                      ret = smb_read_page_byte(I2C_DEVICE_ADDR, SFP_PAGE_05H, PCBA_SN, param->argv[2], PCBA_SN_LEN);
 751   2                      JUDGE_RETURN(ret);
 752   2                      uart_printf("\r\nPcba_sn:%s",param->argv[2]);
 753   2              }
 754   1              else
 755   1              {
 756   2                      ret = RET_FAILED;
 757   2              }
 758   1      
 759   1              return ret;
 760   1      }
 761          
 762          static RETURN_VALUE_TYPE prvDispPcbaCodeConfig(PARAM_INFO_T  *param)
 763          {
 764   1              uint8_t  ret = RET_OK;
 765   1      
 766   1              if (!strcmp(param->argv[0],"set"))
 767   1              {
 768   2                      ret = smb_write_page_byte(I2C_DEVICE_ADDR, SFP_PAGE_05H, PCBA_CODE, param->argv[2], PCBA_CODE_LEN);
 769   2              }
 770   1              else if (!strcmp(param->argv[0],"get"))
 771   1              {
 772   2                      ret = smb_read_page_byte(I2C_DEVICE_ADDR, SFP_PAGE_05H, PCBA_CODE, param->argv[2], PCBA_CODE_LEN);
 773   2                      JUDGE_RETURN(ret);
 774   2                      uart_printf("\r\nPcba_code:%s",param->argv[2]);
 775   2              }
 776   1              else
 777   1              {
 778   2                      ret = RET_FAILED;
 779   2              }
 780   1      
 781   1              return ret;
 782   1      }
 783          
 784          static RETURN_VALUE_TYPE prvDispBondingConfig()
 785          {
 786   1              return qsfp28_msa_page4_dbg_cmd(DBG_BONDING_MODE);
 787   1      }
 788          
 789          static RETURN_VALUE_TYPE prvDispFactoryResetConfig()
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 14  

 790          {
 791   1              return qsfp28_msa_page4_dbg_cmd(DBG_FACTORY_RESET_CMD);
 792   1      }
 793          
 794          static uint8_t _cli_laser_tx_sn_cmd(PARAM_INFO_T  *param)
 795          {
 796   1              uint8_t  ret = RET_OK;
 797   1      
 798   1              if (!strcmp(param->argv[0],"set"))
 799   1              {
 800   2                      ret = smb_write_page_byte(I2C_DEVICE_ADDR, SFP_PAGE_05H, LASER_TX_SN, param->argv[2], LASER_TX_SN_LEN);
 801   2              }
 802   1              else if (!strcmp(param->argv[0],"get"))
 803   1              {
 804   2                      ret = smb_read_page_byte(I2C_DEVICE_ADDR, SFP_PAGE_05H,  LASER_TX_SN, param->argv[2], LASER_TX_SN_LEN);
 805   2                      JUDGE_RETURN(ret);
 806   2                      uart_printf("\r\nLaser_tx_sn:%s",param->argv[2]);
 807   2              }
 808   1              else
 809   1              {
 810   2                      ret = RET_FAILED;
 811   2              }
 812   1      
 813   1              return ret;
 814   1      }
 815          
 816          static uint8_t _cli_rx_losa_cmd(PARAM_INFO_T  *param)
 817          {
 818   1              uint16_t  value16 = 0;
 819   1              uint8_t ret = RET_OK, channel = 0;
 820   1      
 821   1              const uint8_t losa_addr[] = {RX_LOSA_THLD_CH0_MSB, RX_LOSA_THLD_CH1_MSB,RX_LOSA_THLD_CH2_MSB,RX_LOSA_THLD
             -_CH3_MSB};
 822   1      
 823   1              if(RET_FAILED == (channel = _qsfp28_get_channel(param->argv[1])))
 824   1              {
 825   2                      return RET_FAILED;
 826   2              }
 827   1      
 828   1              if (!strcmp(param->argv[0],"set"))   //set [ch0|ch1|ch2|ch3] losa_thld value(uA)
 829   1              {
 830   2                      if(channel >= CHANNEL0 && channel < CHANNEL_MAX)
 831   2                      {
 832   3                              value16 = com_str_to_int16(param->argv[3]);
 833   3                              ret = smb_write_page_byte(I2C_DEVICE_ADDR, SFP_PAGE_08H, losa_addr[channel], (uint8_t *)&value16, 2);
 834   3                      }
 835   2                      else
 836   2                      {
 837   3                              ret = RET_FAILED;
 838   3                      }
 839   2              }
 840   1              else if (!strcmp(param->argv[0],"get"))
 841   1              {
 842   2                      if(channel >= CHANNEL0 && channel < CHANNEL_MAX)
 843   2                      {
 844   3                              ret = smb_read_page_byte(I2C_DEVICE_ADDR, SFP_PAGE_08H, losa_addr[channel], (uint8_t *)&value16, 2);
 845   3                              JUDGE_RETURN(ret);
 846   3                              uart_printf("\r\nRx_losa_thld%bu:%hu",channel, value16);
 847   3                      }
 848   2                      else
 849   2                      {
 850   3                              ret = RET_FAILED;
 851   3                      }
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 15  

 852   2              }
 853   1              else
 854   1              {
 855   2                      ret = RET_FAILED;
 856   2              }
 857   1      
 858   1              return ret;
 859   1      }
 860          
 861          static uint8_t _cli_rx_losd_cmd(PARAM_INFO_T  *param)
 862          {
 863   1              uint16_t  value16 = 0;
 864   1              uint8_t   ret = RET_OK, channel = 0;
 865   1      
 866   1              const uint8_t losd_addr[] = {RX_LOSD_THLD_CH0_MSB, RX_LOSD_THLD_CH1_MSB,RX_LOSD_THLD_CH2_MSB,RX_LOSD_THLD
             -_CH3_MSB};
 867   1      
 868   1              if(RET_FAILED == (channel = _qsfp28_get_channel(param->argv[1])))
 869   1              {
 870   2                      return RET_FAILED;
 871   2              }
 872   1      
 873   1              if (!strcmp(param->argv[0],"set"))   //set [ch0|ch1|ch2|ch3] losd_thld value(uA)
 874   1              {
 875   2                      if(channel >= CHANNEL0 && channel < CHANNEL_MAX)
 876   2                      {
 877   3                              value16 = com_str_to_int16(param->argv[3]);
 878   3                              ret = smb_write_page_byte(I2C_DEVICE_ADDR, SFP_PAGE_08H, losd_addr[channel], (uint8_t *)&value16, 2);
 879   3                      }
 880   2              }
 881   1              else if (!strcmp(param->argv[0],"get"))
 882   1              {
 883   2                      if(channel >= CHANNEL0 && channel < CHANNEL_MAX)
 884   2                      {
 885   3                              ret = smb_read_page_byte(I2C_DEVICE_ADDR, SFP_PAGE_08H, losd_addr[channel], (uint8_t *)&value16, 2);
 886   3                              JUDGE_RETURN(ret);
 887   3                              uart_printf("\r\nRx_losd_thld%bu:%hu",channel, value16);
 888   3                      }
 889   2              }
 890   1              else
 891   1              {
 892   2                      ret = RET_FAILED;
 893   2              }
 894   1      
 895   1              return ret;
 896   1      }
 897          
 898          static uint8_t _cli_rx_los_mode_cmd(PARAM_INFO_T  *param)
 899          {
 900   1              uint8_t  value8 = 0, ret = RET_OK;
 901   1      
 902   1              if (!strcmp(param->argv[0],"set"))   //set rx_los mode [0|1]
 903   1              {
 904   2                      value8 = com_str_to_int16(param->argv[3]);
 905   2                      ret = smb_write_page_byte(I2C_DEVICE_ADDR, SFP_PAGE_08H, RX_LOS_MODE, (uint8_t *)&value8, 1);
 906   2              }
 907   1              else if (!strcmp(param->argv[0],"get"))
 908   1              {
 909   2                      ret = smb_read_page_byte(I2C_DEVICE_ADDR, SFP_PAGE_08H, RX_LOS_MODE, (uint8_t *)&value8, 1);
 910   2                      JUDGE_RETURN(ret);
 911   2                      uart_printf("\r\nRx_los_mode:%bu",value8);
 912   2              }
 913   1              else
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 16  

 914   1              {
 915   2                      ret = RET_FAILED;
 916   2              }
 917   1      
 918   1              return ret;
 919   1      }
 920          
 921          static uint8_t _cli_rssi_darka_cmd(PARAM_INFO_T  *param)
 922          {
 923   1              uint16_t  value16 = 0;
 924   1              uint8_t ret = RET_OK, channel = 0, i = 0;
 925   1      
 926   1              const uint8_t rssi_darka_addr[] = {RSSI_DRAKA_THLD_CH0_MSB, RSSI_DRAKA_THLD_CH1_MSB,RSSI_DRAKA_THLD_CH2_M
             -SB,RSSI_DRAKA_THLD_CH3_MSB};
 927   1      
 928   1              if(RET_FAILED == (channel = _qsfp28_get_channel(param->argv[1])))
 929   1              {
 930   2                      return RET_FAILED;
 931   2              }
 932   1      
 933   1              if (!strcmp(param->argv[0],"set"))   //set [ch0|ch1|ch2|ch3|all] darka_thld value(uA)
 934   1              {
 935   2                      if(channel >= CHANNEL0 && channel < CHANNEL_MAX)
 936   2                      {
 937   3                              value16 = com_str_to_int16(param->argv[3]);
 938   3                              ret = smb_write_page_byte(I2C_DEVICE_ADDR, SFP_PAGE_08H, rssi_darka_addr[channel], (uint8_t *)&value16,
             - 2);
 939   3                      }
 940   2                      else if(channel == CHANNEL_MAX)
 941   2                      {
 942   3                              for(i = 0; i < CHANNEL_MAX; i++)
 943   3                              {
 944   4                                      value16 = com_str_to_int16(param->argv[3]);
 945   4                                      ret = smb_write_page_byte(I2C_DEVICE_ADDR, SFP_PAGE_08H, rssi_darka_addr[i], (uint8_t *)&value16, 2);
 946   4                                      JUDGE_RETURN(ret);
 947   4                              }
 948   3                      }
 949   2                      else
 950   2                      {
 951   3                              ret = RET_FAILED;
 952   3                      }
 953   2              }
 954   1              else if (!strcmp(param->argv[0],"get"))
 955   1              {
 956   2                      if(channel >= CHANNEL0 && channel < CHANNEL_MAX)
 957   2                      {
 958   3                              ret = smb_read_page_byte(I2C_DEVICE_ADDR, SFP_PAGE_08H, rssi_darka_addr[channel], (uint8_t *)&value16, 
             -2);
 959   3                              JUDGE_RETURN(ret);
 960   3                              uart_printf("\r\nRssi_darka_thld%bu:%hu",channel, value16);
 961   3                      }
 962   2                      else if(channel == CHANNEL_MAX)
 963   2                      {
 964   3                              for(i = 0; i < CHANNEL_MAX; i++)
 965   3                              {
 966   4                                      ret = smb_read_page_byte(I2C_DEVICE_ADDR, SFP_PAGE_08H, rssi_darka_addr[i], (uint8_t *)&value16, 2);
 967   4                                      JUDGE_RETURN(ret);
 968   4                                      uart_printf("\r\nRssi_darka_thld%bu:%hu",i, value16);
 969   4                              }
 970   3                      }
 971   2                      else
 972   2                      {
 973   3                              ret = RET_FAILED;
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 17  

 974   3                      }
 975   2              }
 976   1              else
 977   1              {
 978   2                      ret = RET_FAILED;
 979   2              }
 980   1      
 981   1              return ret;
 982   1      }
 983          
 984          static uint8_t _cli_rssi_darkd_cmd(PARAM_INFO_T  *param)
 985          {
 986   1              uint16_t  value16 = 0;
 987   1              uint8_t   ret = RET_OK, channel = 0, i = 0;
 988   1      
 989   1              const uint8_t rssi_darkd_addr[] = {RSSI_DRAKD_THLD_CH0_MSB, RSSI_DRAKD_THLD_CH1_MSB,RSSI_DRAKD_THLD_CH2_M
             -SB,RSSI_DRAKD_THLD_CH3_MSB};
 990   1      
 991   1              if(RET_FAILED == (channel = _qsfp28_get_channel(param->argv[1])))
 992   1              {
 993   2                      return RET_FAILED;
 994   2              }
 995   1      
 996   1              if (!strcmp(param->argv[0],"set"))   //set [ch0|ch1|ch2|ch3] darkd_thld value(uA)
 997   1              {
 998   2                      if(channel >= CHANNEL0 && channel < CHANNEL_MAX)
 999   2                      {
1000   3                              value16 = com_str_to_int16(param->argv[3]);
1001   3                              ret = smb_write_page_byte(I2C_DEVICE_ADDR, SFP_PAGE_08H, rssi_darkd_addr[channel], (uint8_t *)&value16,
             - 2);
1002   3                      }
1003   2                      else if(channel == CHANNEL_MAX)
1004   2                      {
1005   3                              for(i = 0; i < CHANNEL_MAX; i++)
1006   3                              {
1007   4                                      value16 = com_str_to_int16(param->argv[3]);
1008   4                                      ret = smb_write_page_byte(I2C_DEVICE_ADDR, SFP_PAGE_08H, rssi_darkd_addr[i], (uint8_t *)&value16, 2);
1009   4                                      JUDGE_RETURN(ret);
1010   4                              }
1011   3                      }
1012   2              }
1013   1              else if (!strcmp(param->argv[0],"get"))
1014   1              {
1015   2                      if(channel >= CHANNEL0 && channel < CHANNEL_MAX)
1016   2                      {
1017   3                              ret = smb_read_page_byte(I2C_DEVICE_ADDR, SFP_PAGE_08H, rssi_darkd_addr[channel], (uint8_t *)&value16, 
             -2);
1018   3                              JUDGE_RETURN(ret);
1019   3                              uart_printf("\r\nRssi_darkd_thld%bu:%hu",channel, value16);
1020   3                      }
1021   2                      else if(channel == CHANNEL_MAX)
1022   2                      {
1023   3                              for(i = 0; i < CHANNEL_MAX; i++)
1024   3                              {
1025   4                                      ret = smb_read_page_byte(I2C_DEVICE_ADDR, SFP_PAGE_08H, rssi_darkd_addr[i], (uint8_t *)&value16, 2);
1026   4                                      JUDGE_RETURN(ret);
1027   4                                      uart_printf("\r\nRssi_darkd_thld%bu:%hu",i, value16);
1028   4                              }
1029   3                      }
1030   2                      else
1031   2                      {
1032   3                              ret = RET_FAILED;
1033   3                      }
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 18  

1034   2              }
1035   1              else
1036   1              {
1037   2                      ret = RET_FAILED;
1038   2              }
1039   1      
1040   1              return ret;
1041   1      }
1042          
1043          static uint8_t _cli_tx_config_laser(uint8_t channel, uint8_t enable)
1044          {
1045   1              uint8_t value = 0, ret = RET_OK, tx_dis = 0;
1046   1      
1047   1              ret = i2c_master_read(I2C_DEVICE_ADDR, MSA_TX_ENABLE, (uint8_t *)&tx_dis, 1);
1048   1      
1049   1              tx_dis = tx_dis & 0x0F;
1050   1      
1051   1              if(channel >= CHANNEL0 && channel < CHANNEL_MAX)
1052   1              {
1053   2                      tx_dis = ((enable) ? (MY_CLEAR_BIT(tx_dis, channel)) : (MY_SET_BIT(tx_dis, channel)));  //enable = 1, Di
             -sable laser , enable = 0, Enable laser
1054   2              }
1055   1              else if(channel == CHANNEL_MAX)
1056   1              {
1057   2                      tx_dis =  ((enable) ? (U8_CLEAR_LSB_4BITS(tx_dis)) : (U8_SET_LSB_4BITS(tx_dis)));
1058   2              }
1059   1      
1060   1              ret = i2c_master_write(I2C_DEVICE_ADDR, MSA_TX_ENABLE, (uint8_t *)&tx_dis, 1);
1061   1      
1062   1              return ret;
1063   1      }
1064          
1065          static uint8_t _cli_tx_get_laser_status(uint8_t channel)
1066          {
1067   1              uint8_t tmp = 0, value = 0, ret = RET_OK;
1068   1      
1069   1              if(channel >= CHANNEL0 && channel < CHANNEL_MAX)
1070   1              {
1071   2                      ret = i2c_master_read(I2C_DEVICE_ADDR, MSA_TX_ENABLE, (uint8_t *)&value, 1);
1072   2                      JUDGE_RETURN(ret);
1073   2                      tmp = MY_GET_BIT(value, channel);
1074   2                      uart_printf("\r\nPrbs%bu:%bu",channel, tmp);
1075   2              }
1076   1              else if(channel == CHANNEL_MAX)
1077   1              {
1078   2                      for(channel = 0; channel  < CHANNEL_MAX; channel ++)
1079   2                      {
1080   3                              ret = i2c_master_read(I2C_DEVICE_ADDR, MSA_TX_ENABLE, (uint8_t *)&value, 1);
1081   3                              JUDGE_RETURN(ret);
1082   3                              tmp = MY_GET_BIT(value, channel);
1083   3                              uart_printf("\r\nPrbs%bu:%bu",channel, tmp);
1084   3                      }
1085   2              }
1086   1              return ret;
1087   1      }
1088          
1089          static uint8_t _cli_tx_laser_cmd(PARAM_INFO_T  *param)
1090          {
1091   1              uint8_t  channel = 0, ret = RET_OK;
1092   1      
1093   1              channel = _qsfp28_get_channel(param->argv[1]);
1094   1      
1095   1              if (!strcmp(param->argv[0],"set"))
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 19  

1096   1              {
1097   2                      if (!strcmp(param->argv[3],"enable"))  //[set|get] [ch0|ch1|ch2|ch3|all] tx [enable|disable]
1098   2                      {
1099   3                              ret = _cli_tx_config_laser(channel, ENABLE_LAESER);
1100   3                      }
1101   2                      else if(!strcmp(param->argv[3],"disable"))
1102   2                      {
1103   3                              ret = _cli_tx_config_laser(channel, DISABLE_LAESER);
1104   3                      }
1105   2              }
1106   1              else if(!strcmp(param->argv[0],"get"))
1107   1              {
1108   2                      ret = _cli_tx_get_laser_status(channel);
1109   2              }
1110   1              return ret;
1111   1      }
1112          
1113          static uint8_t _cli_laser_rx_sn_cmd(PARAM_INFO_T  *param)
1114          {
1115   1              uint8_t  ret = RET_OK;
1116   1      
1117   1              if (!strcmp(param->argv[0],"set"))
1118   1              {
1119   2                      ret = smb_write_page_byte(I2C_DEVICE_ADDR, SFP_PAGE_05H, LASER_RX_SN, param->argv[2], LASER_RX_SN_LEN);
1120   2              }
1121   1              else if (!strcmp(param->argv[0],"get"))
1122   1              {
1123   2                      ret = smb_read_page_byte(I2C_DEVICE_ADDR, SFP_PAGE_05H, LASER_RX_SN, param->argv[2], LASER_RX_SN_LEN);
1124   2                      JUDGE_RETURN(ret);
1125   2                      uart_printf("\r\nLaser_rx_sn:%s",param->argv[2]);
1126   2              }
1127   1              else
1128   1              {
1129   2                      ret = RET_FAILED;
1130   2              }
1131   1      
1132   1              return ret;
1133   1      }
1134          
1135          static uint8_t _cli_pic_code_cmd(PARAM_INFO_T  *param)
1136          {
1137   1              uint8_t  ret = RET_OK;
1138   1      
1139   1              if (!strcmp(param->argv[0],"set"))
1140   1              {
1141   2                      ret = smb_write_page_byte(I2C_DEVICE_ADDR, SFP_PAGE_05H, PICCODE, param->argv[2], PICCODE_LEN);
1142   2              }
1143   1              else if (!strcmp(param->argv[0],"get"))
1144   1              {
1145   2                      ret = smb_read_page_byte(I2C_DEVICE_ADDR, SFP_PAGE_05H, PICCODE, param->argv[2], PICCODE_LEN);
1146   2                      JUDGE_RETURN(ret);
1147   2                      uart_printf("\r\nPic_code:%s",param->argv[2]);
1148   2              }
1149   1              else
1150   1              {
1151   2                      ret = RET_FAILED;
1152   2              }
1153   1      
1154   1              return ret;
1155   1      }
1156          
1157          static uint8_t _cli_module_type_cmd(PARAM_INFO_T  *param)
1158          {
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 20  

1159   1              uint8_t  ret = RET_OK;
1160   1              uint16_t value16 = 0;
1161   1      
1162   1              if (!strcmp(param->argv[0],"set"))
1163   1              {
1164   2                      value16 = com_str_to_int16(param->argv[2]);
1165   2                      ret = smb_write_page_byte(I2C_DEVICE_ADDR, SFP_PAGE_05H, MSA_OFF_MODULE_TYPE, (uint8_t *)&value16, 2);
1166   2              }
1167   1              else if (!strcmp(param->argv[0],"get"))
1168   1              {
1169   2                      ret = smb_read_page_byte(I2C_DEVICE_ADDR, SFP_PAGE_05H, MSA_OFF_MODULE_TYPE, (uint8_t *)&value16, 2);
1170   2                      JUDGE_RETURN(ret);
1171   2                      uart_printf("\r\nModule_type:0x%hx",value16);
1172   2              }
1173   1              else
1174   1              {
1175   2                      ret = RET_FAILED;
1176   2              }
1177   1      
1178   1              return ret;
1179   1      }
1180          
1181          static uint8_t _cli_hw_ver_cmd(PARAM_INFO_T  *param)
1182          {
1183   1              uint8_t  value = 0, ret = RET_OK;
1184   1      
1185   1              if (!strcmp(param->argv[0],"set"))
1186   1              {
1187   2                      value = (uint8_t)com_str_to_int16(param->argv[2]);
1188   2                      ret = smb_write_page_byte(I2C_DEVICE_ADDR, SFP_PAGE_05H, MSA_OFF_HW_VER, (uint8_t *)&value, 1);
1189   2      
1190   2              }
1191   1              else if (!strcmp(param->argv[0],"get"))
1192   1              {
1193   2                      ret = smb_read_page_byte(I2C_DEVICE_ADDR, SFP_PAGE_05H, MSA_OFF_HW_VER, (uint8_t *)&value, 1);
1194   2                      JUDGE_RETURN(ret);
1195   2                      uart_printf("\r\nHw_ver:%bx",value);
1196   2              }
1197   1              else
1198   1              {
1199   2                      ret = RET_FAILED;
1200   2              }
1201   1      
1202   1              return ret;
1203   1      }
1204          
1205          
1206          static uint8_t _cli_set_lut_tab(LUT_SHOW_TYPE show_type, MSA_LUT_TYPE lut_type, PARAM_INFO_T  *param)
1207          {
1208   1              MSA_LASER_CH_CFG_T cfg;
1209   1              uint8_t  channel = 0, ret = RET_OK;
1210   1      
1211   1               ret = ((RET_FAILED == (channel = _qsfp28_get_channel(param->argv[1]))) ? RET_FAILED : RET_OK);
1212   1      
1213   1               if(channel == CHANNEL_MAX)
1214   1               {
1215   2                       ret = RET_FAILED;
1216   2               }
1217   1               else if (!strcmp(param->argv[0],"set"))
1218   1               {
1219   2                      if(!strcmp(param->argv[3],"now"))
1220   2                      {
1221   3                              ret = qsfp28_set_lut_tab_para_from_reg_inner(channel, lut_type + 1);
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 21  

1222   3                              return ret;
1223   3                      }
1224   2                      cfg.temp  = com_str_to_int16(param->argv[3]);
1225   2                      cfg.bias  = com_str_to_int16(param->argv[4]);
1226   2                      cfg.mod   = com_str_to_int16(param->argv[5]);
1227   2                      cfg.cross = com_str_to_int16(param->argv[6]);
1228   2                      cfg.temp  = cfg.temp * DDMI_CALI_TEMP_SCALE;                    //because the module receive result is actual temp * 2
             -56
1229   2                      ret = qsfp28_set_lut_tab(channel, lut_type, cfg);
1230   2               }
1231   1               else if (!strcmp(param->argv[0],"get"))
1232   1               {
1233   2                      ret = qsfp28_get_lut_tab(channel, show_type, lut_type);
1234   2               }
1235   1               else
1236   1               {
1237   2                       ret = RET_FAILED;
1238   2               }
1239   1      
1240   1               return ret;
1241   1      }
1242          
1243          static uint8_t _cli_get_all_lut_tab()
1244          {
1245   1              uint8_t channel = 0, ret = RET_OK;
1246   1      
1247   1              uart_printf("\r\nchN    temp     bias    mod     crossing");
1248   1              uart_printf("\r\n---------------------------------------");
1249   1              for(channel = 0; channel < CHANNEL_MAX; channel++)
1250   1              {
1251   2                      ret = qsfp28_get_lut_tab(channel,ALL_LUT_INFO, MSA_LUT_TYPE_LOW_TEMP);
1252   2                      ret = qsfp28_get_lut_tab(channel,ALL_LUT_INFO, MSA_LUT_TYPE_MID_TEMP);
1253   2                      ret = qsfp28_get_lut_tab(channel,ALL_LUT_INFO, MSA_LUT_TYPE_HI_TEMP);
1254   2              }
1255   1      
1256   1              return ret;
1257   1      }
1258          
1259          static RETURN_VALUE_TYPE prvDispLuttabConfig(PARAM_INFO_T  *param) //[get|set] [ch0|ch1|ch2|ch3] #[cur|fix
             -ed_temp] lut tab
1260          {
1261   1              uint8_t channel = 0, ret = RET_OK;
1262   1              int16_t value16 = 0;
1263   1      
1264   1              if(RET_FAILED == (channel = _qsfp28_get_channel(param->argv[1])))
1265   1              {
1266   2                      return RET_FAILED;
1267   2              }
1268   1      
1269   1              if (!strcmp(param->argv[0],"get"))
1270   1              {
1271   2                      if (!strcmp(param->argv[2],"cur")) //get ch1 [cur|fixed_temp] lut tab
1272   2                      {
1273   3                              ret = qsfp28_get_cur_apc_value(channel);
1274   3                      }
1275   2                      else
1276   2                      {
1277   3                              value16 = com_str_to_int16(param->argv[2]);
1278   3                              ret = qsfp28_get_fixed_temp_point_apc_value(value16, channel);
1279   3                      }
1280   2              }
1281   1      
1282   1              /*
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 22  

1283   1              else if (!strcmp(param->argv[0],"set"))
1284   1              {
1285   1                      if (!strcmp(param->argv[2],"cur")) //set ch1 [cur|fixed_temp] lut tab
1286   1                      {
1287   1                              ret = qsfp28_set_cur_apc_value(channel);
1288   1                      }
1289   1                      else
1290   1                      {
1291   1                              value16 = com_str_to_int16(param->argv[2]);
1292   1                              ret = qsfp28_set_fixed_temp_point_apc_value((uint8_t)value16, channel);
1293   1                      }
1294   1              }
1295   1              */
1296   1      
1297   1              return ret;
1298   1      }
1299          
1300          static uint8_t _cli_ddmi_cali(PARAM_INFO_T  *param)
1301          {
1302   1              uint8_t channel = 0, ret = RET_OK;
1303   1              DDMI_CALI_PARA_T cali_para;
1304   1      
1305   1              if (!strcmp(param->argv[2],"temp_offset")) //set|get ddmi_cali temp_offset
1306   1              {
1307   2                      if (!strcmp(param->argv[0],"set"))
1308   2                      {
1309   3                              if(CHECK_DDMI_CALI_TEMP_OFFSET(atof(param->argv[3])))
1310   3                              {
1311   4                                      cali_para.temp = (int16_t)(atof(param->argv[3]) * (float)DDMI_CALI_TEMP_SCALE);
1312   4                                      ret = qsfp28_set_ddmi_cali_para(DDMI_TEMP, 0, &cali_para);  //uint:1/256 C
1313   4                              }
1314   3                              else
1315   3                              {
1316   4                                      uart_printf( "\r\n Temp_offset is out of range");
1317   4                                      ret = RET_FAILED;
1318   4                              }
1319   3                      }
1320   2                      else if (!strcmp(param->argv[0],"get"))
1321   2                      {
1322   3                              ret = qsfp28_get_ddmi_cali_para(DDMI_TEMP, 0, &cali_para);//uint:1/256 C
1323   3                              JUDGE_RETURN(ret);
1324   3                              uart_printf( "\r\n temp_offset:%f(C)", (float)cali_para.temp / (float)DDMI_CALI_TEMP_SCALE);
1325   3                      }
1326   2                      else
1327   2                      {
1328   3                              ret = RET_FAILED;
1329   3                      }
1330   2              }
1331   1              else if (!strcmp(param->argv[2],"vcc_offset")) //set|get ddmi_cali_para vcc_offset
1332   1              {
1333   2                      if (!strcmp(param->argv[0],"set"))
1334   2                      {
1335   3                              if(CHECK_DDMI_CALI_VCC_OFFSET(atof(param->argv[3])))
1336   3                              {
1337   4                                      cali_para.vcc = (int16_t)(atof(param->argv[3]) * 1000.0 * 10);  //uint:0.1mv
1338   4                                      ret = qsfp28_set_ddmi_cali_para(DDMI_VCC, 0, &cali_para);
1339   4                              }
1340   3                              else
1341   3                              {
1342   4                                      uart_printf( "\r\n Vcc_offset is out of range");
1343   4                                      ret = RET_FAILED;
1344   4                              }
1345   3                      }
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 23  

1346   2                      else if (!strcmp(param->argv[0],"get"))
1347   2                      {
1348   3                              ret = qsfp28_get_ddmi_cali_para(DDMI_VCC, 0, &cali_para);//uint:0.1mv
1349   3                              JUDGE_RETURN(ret);
1350   3                              uart_printf( "\r\n vcc_offset:%f(V)", (float)cali_para.vcc * 0.1 / 1000.0);
1351   3                      }
1352   2                      else
1353   2                      {
1354   3                              ret = RET_FAILED;
1355   3                      }
1356   2              }
1357   1              else if (!strcmp(param->argv[3],"bias_offset"))  //set|get ddmi_cali_para [ch0|ch1|ch2|ch3|all] bias_offs
             -et bias_offset_x bias_offset_y
1358   1              {
1359   2                      uint8_t i = 0;
1360   2      
1361   2                      if(RET_FAILED == (channel = _qsfp28_get_channel(param->argv[2])))
1362   2                      {
1363   3                              return RET_FAILED;
1364   3                      }
1365   2      
1366   2                      if (!strcmp(param->argv[0],"set"))
1367   2                      {
1368   3                              if(channel >= CHANNEL0 && channel < CHANNEL_MAX)
1369   3                              {
1370   4                                      cali_para.current[channel].bias.bias_offset1 = (int16_t)(atof(param->argv[4]) * 10.0);  //uint:0.1mA
1371   4                                      cali_para.current[channel].bias.bias_offset2 = (int16_t)(atof(param->argv[5]) * 10.0);  //uint:0.1mA
1372   4                                      ret = qsfp28_set_ddmi_cali_para(DDMI_BIAS, channel, &cali_para);
1373   4                              }
1374   3                              else if(channel == CHANNEL_MAX)
1375   3                              {
1376   4                                      for(i = CHANNEL0; i < CHANNEL_MAX; i++)
1377   4                                      {
1378   5                                              cali_para.current[i].bias.bias_offset1 = (int16_t)(atof(param->argv[4]) * 10.0);  //uint:0.1mA
1379   5                                              cali_para.current[i].bias.bias_offset2 = (int16_t)(atof(param->argv[5]) * 10.0);  //uint:0.1mA
1380   5                                              ret = qsfp28_set_ddmi_cali_para(DDMI_BIAS, i, &cali_para);
1381   5                                              JUDGE_RETURN(ret);
1382   5                                      }
1383   4                              }
1384   3                      }
1385   2                      else if (!strcmp(param->argv[0],"get"))
1386   2                      {
1387   3                              if(channel >= CHANNEL0 && channel < CHANNEL_MAX)
1388   3                              {
1389   4                                      ret = qsfp28_get_ddmi_cali_para(DDMI_BIAS, channel, &cali_para); //uint:0.1mA
1390   4                                      JUDGE_RETURN(ret);
1391   4                                      uart_printf( "\r\n ch%bu-bias_offset_x:%f(mA)\r\n ch%bu-bias_offset_y:%f(mA)",  \
1392   4                                                      channel,(float)cali_para.current[channel].bias.bias_offset1 * 0.1,                \
1393   4                                                      channel,(float)cali_para.current[channel].bias.bias_offset2 * 0.1);
1394   4                              }
1395   3                              else if(channel == CHANNEL_MAX)
1396   3                              {
1397   4                                      for(i = CHANNEL0; i < CHANNEL_MAX; i++)
1398   4                                      {
1399   5                                              ret = qsfp28_get_ddmi_cali_para(DDMI_BIAS, i, &cali_para); //uint:0.1mA
1400   5                                              JUDGE_RETURN(ret);
1401   5                                              uart_printf( "\r\n ch%bu-bias_offset_x:%f(mA)\r\n ch%bu-bias_offset_y:%f(mA)",  \
1402   5                                                              i,(float)cali_para.current[i].bias.bias_offset1 * 0.1,            \
1403   5                                                              i,(float)cali_para.current[i].bias.bias_offset2 * 0.1);
1404   5                                      }
1405   4                              }
1406   3                      }
1407   2                      else
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 24  

1408   2                      {
1409   3                              ret = RET_FAILED;
1410   3                      }
1411   2              }
1412   1              else if (!strcmp(param->argv[3],"txpwr"))  //set|get ddmi_cali_para [ch0|ch1|ch2|ch3] txpwr TXPOWER BIAS
1413   1              {
1414   2                      if(RET_FAILED == (channel = _qsfp28_get_channel(param->argv[2])))
1415   2                      {
1416   3                              return RET_FAILED;
1417   3                      }
1418   2      
1419   2                      if (!strcmp(param->argv[0],"set"))
1420   2                      {
1421   3                              cali_para.current[channel].txpower.txpower1 = (uint16_t)(pow(10.0, atof(param->argv[4]) / 10.0) * 1000.
             -0 * 10.0); //uint:0.1uW
1422   3                              cali_para.current[channel].txpower.bias1    = (uint16_t)(atof(param->argv[5]) * 10.0); //uint:0.1mA
1423   3      
1424   3                              cali_para.current[channel].txpower.txpower2 = (uint16_t)(pow(10.0, atof(param->argv[6]) / 10.0) * 1000.
             -0 * 10.0); //uint:0.1uW
1425   3                              cali_para.current[channel].txpower.bias2    = (uint16_t)(atof(param->argv[7]) * 10.0); //uint:0.1mA
1426   3                              ret = qsfp28_set_ddmi_cali_para(DDMI_TXMON, channel, &cali_para);
1427   3                      }
1428   2                      else if (!strcmp(param->argv[0],"get"))
1429   2                      {
1430   3                              float txpower1 = 0.0, txpower2 = 0.0;
1431   3      
1432   3                              ret = qsfp28_get_ddmi_cali_para(DDMI_TXMON, channel, &cali_para);
1433   3                              JUDGE_RETURN(ret);
1434   3                              txpower1 = (float)cali_para.current[channel].txpower.txpower1  * 0.1 /1000.0; //uint:mW
1435   3                              txpower2 = (float)cali_para.current[channel].txpower.txpower2  * 0.1 /1000.0; //uint:mW
1436   3      
1437   3                              uart_printf( "\r\nch%bu-txpower1:%f(dbm)\r\nch%bu-bias1   :%f(mA)\r\nch%bu-txpower2:%f(dbm)\r\nch%bu-bi
             -as2  :%f(mA)", \
1438   3                                              channel, (float)(10 * log10(txpower1)),                                                         \
1439   3                                              channel, (float)cali_para.current[channel].txpower.bias1 * 0.1 ,        \
1440   3                                              channel, (float)(10 * log10(txpower2)),                                                 \
1441   3                                              channel, (float)cali_para.current[channel].txpower.bias2 * 0.1);
1442   3                      }
1443   2                      else
1444   2                      {
1445   3                              ret = RET_FAILED;
1446   3                      }
1447   2              }
1448   1              else if (!strcmp(param->argv[3],"rxpwr"))  //set|get ddmi_cali_para [ch0|ch1|ch2|ch3] rxpwr RXPOWER1 RSSI
             -1 RXPOWER2 RSSI2
1449   1              {
1450   2                      if(RET_FAILED == (channel = _qsfp28_get_channel(param->argv[2])))
1451   2                      {
1452   3                              return RET_FAILED;
1453   3                      }
1454   2      
1455   2                      if (!strcmp(param->argv[0],"set"))
1456   2                      {
1457   3                              if(CHECK_DDMI_CALI_POWER_OFFSET(atof(param->argv[4])) && //CHECK_DDMI_CALI_RSSI_OFFSET(com_str_to_int16
             -(param->argv[5])) &&&& CHECK_DDMI_CALI_RSSI_OFFSET(com_str_to_int16(param->argv[7]))
1458   3                                 CHECK_DDMI_CALI_POWER_OFFSET(atof(param->argv[6])) )
1459   3                              {
1460   4                                      cali_para.current[channel].rxpower.rxpower1 = (uint16_t)(pow(10.0, atof(param->argv[4]) / 10.0) * 1000
             -.0 * 10.0); //uint:0.1uW
1461   4                                      cali_para.current[channel].rxpower.rssi1    = (uint16_t)com_str_to_int16(param->argv[5]);
1462   4                                      cali_para.current[channel].rxpower.rxpower2 = (uint16_t)(pow(10.0, atof(param->argv[6])/ 10.0) * 1000.
             -0 * 10.0); //uint:0.1uW
1463   4                                      cali_para.current[channel].rxpower.rssi2    = (uint16_t)com_str_to_int16(param->argv[7]);
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 25  

1464   4      
1465   4                                      ret = qsfp28_set_ddmi_cali_para(DDMI_RSSI, channel, &cali_para);
1466   4                              }
1467   3                              else
1468   3                              {
1469   4                                      uart_printf( "\r\nRxpower or rssi is out of range");
1470   4                                      ret = RET_FAILED;
1471   4                              }
1472   3                      }
1473   2                      else if (!strcmp(param->argv[0],"get"))
1474   2                      {
1475   3                              float rxpower1 = 0.0, rxpower2 = 0.0;
1476   3      
1477   3                              ret = qsfp28_get_ddmi_cali_para(DDMI_RSSI, channel, &cali_para);
1478   3                              JUDGE_RETURN(ret);
1479   3      
1480   3                              rxpower1 = (float)cali_para.current[channel].rxpower.rxpower1  * 0.1 /1000.0; //uint:mW
1481   3                              rxpower2 = (float)cali_para.current[channel].rxpower.rxpower2  * 0.1 /1000.0; //uint:mW
1482   3                              uart_printf( "\r\nch%bu-rxpower1:%f(dbm)\r\nch%bu-rssi1   :%hu(uA)\r\nch%bu-rxpower2:%f(dbm)\r\nch%bu-r
             -ssi2   :%hu(uA)", \
1483   3                                              channel, (float)(10 * log10(rxpower1)),                                                         \
1484   3                                              channel, cali_para.current[channel].rxpower.rssi1 ,     \
1485   3                                              channel, (float)(10 * log10(rxpower2)),                                         \
1486   3                                              channel, cali_para.current[channel].rxpower.rssi2);
1487   3                      }
1488   2                      else
1489   2                      {
1490   3                              ret = RET_FAILED;
1491   3                      }
1492   2              }
1493   1              else
1494   1              {
1495   2                      ret = RET_FAILED;
1496   2              }
1497   1      
1498   1              return ret;
1499   1      }
1500          
1501          static uint8_t _cli_ddmi_cmd(PARAM_INFO_T  *param)
1502          {
1503   1              uint8_t channel = 0, ret = RET_OK;
1504   1      
1505   1               if(!strcmp(param->argv[2],"vcc"))
1506   1               {
1507   2                               ret = qsfp28_get_ddmi(DDMI_VCC, 0, DDMI_CALI_BEFORE);  //get mcu vcc
1508   2               }
1509   1               else if(!strcmp(param->argv[2],"temp"))
1510   1               {
1511   2                               ret = qsfp28_get_ddmi(DDMI_TEMP, 0, DDMI_CALI_BEFORE);  //get mcu temp
1512   2               }
1513   1               else
1514   1               {
1515   2                       channel = (uint8_t)com_str_to_int16(param->argv[3]);
1516   2      
1517   2                       if(!strcmp(param->argv[2],"bias"))
1518   2                       {
1519   3                               ret = qsfp28_get_ddmi(DDMI_BIAS, channel, DDMI_CALI_BEFORE);
1520   3                       }
1521   2                       else if(!strcmp(param->argv[2],"txmon"))
1522   2                       {
1523   3                               ret = qsfp28_get_ddmi(DDMI_TXMON, channel, DDMI_CALI_BEFORE);
1524   3                       }
1525   2                       else if(!strcmp(param->argv[2],"rssi"))
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 26  

1526   2                       {
1527   3                               ret =  qsfp28_get_ddmi(DDMI_RSSI, channel, DDMI_CALI_BEFORE);
1528   3                       }
1529   2                       else
1530   2                       {
1531   3                               ret = RET_FAILED;
1532   3                       }
1533   2               }
1534   1      
1535   1               return ret;
1536   1      }
1537          
1538          
1539          static uint8_t _cli_thrhld_cmd(PARAM_INFO_T  *param)
1540          {
1541   1              uint8_t value = 0, ret = RET_OK;
1542   1              uint16_t value16 = 0;
1543   1              float    tmp_f = 1.0;
1544   1              MSA_PAGE3_ALARM_WARING_THRESHOLD_T type = UNKNOW_ALARM;
1545   1      
1546   1              tmp_f = atof(param->argv[3]);
1547   1      
1548   1              if(!strcmp(param->argv[2],"all"))
1549   1              {
1550   2                      type = HTRHLD_ALL;
1551   2              }
1552   1              else if(!strcmp(param->argv[2],"temp_high_alarm"))  //temp
1553   1              {
1554   2                      type = TEMP_HIGH_ALARM;
1555   2                      value16 = (uint16_t)(tmp_f * (float)DDMI_CALI_TEMP_SCALE);
1556   2              }
1557   1              else if(!strcmp(param->argv[2],"temp_low_alarm"))
1558   1              {
1559   2                      type = TEMP_LOW_ALARM;
1560   2                      value16 = (uint16_t)(tmp_f * (float)DDMI_CALI_TEMP_SCALE);
1561   2              }
1562   1              else if(!strcmp(param->argv[2],"temp_high_warn"))
1563   1              {
1564   2                      type = TEMP_HIGH_WARN;
1565   2                      value16 = (uint16_t)(tmp_f * (float)DDMI_CALI_TEMP_SCALE);
1566   2              }
1567   1              else if(!strcmp(param->argv[2],"temp_low_warn"))
1568   1              {
1569   2                      type = TEMP_LOW_WARN;
1570   2                      value16 = (uint16_t)(tmp_f * (float)DDMI_CALI_TEMP_SCALE);
1571   2              }
1572   1              else if(!strcmp(param->argv[2],"vcc_high_alarm"))  // vcc
1573   1              {
1574   2                      type = VCC_HIGH_ALARM;
1575   2                      value16 = (uint16_t)(tmp_f * 1000.0 * 10.0);
1576   2              }
1577   1              else if(!strcmp(param->argv[2],"vcc_low_alarm"))
1578   1              {
1579   2                      type = VCC_LOW_ALARM;
1580   2                      value16 = (uint16_t)(tmp_f * 1000.0 * 10.0);
1581   2              }
1582   1              else if(!strcmp(param->argv[2],"vcc_high_warn"))
1583   1              {
1584   2                      type = VCC_HIGH_WARN;
1585   2                      value16 = (uint16_t)(tmp_f * 1000.0 * 10.0);
1586   2              }
1587   1              else if(!strcmp(param->argv[2],"vcc_low_warn"))
1588   1              {
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 27  

1589   2                      type = VCC_LOW_WARN;
1590   2                      value16 = (uint16_t)(tmp_f * 1000.0 * 10.0);
1591   2              }
1592   1              else if(!strcmp(param->argv[2],"rxpwr_high_alarm"))  // rxpower
1593   1              {
1594   2                      type = RXPWR_HIGH_ALARM;
1595   2                      value16 = (uint16_t)(pow(10.0, tmp_f/10.0) * 10000.0);
1596   2              }
1597   1              else if(!strcmp(param->argv[2],"rxpwr_low_alarm"))
1598   1              {
1599   2                      type = RXPWR_LOW_ALARM;
1600   2                      value16 = (uint16_t)(pow(10.0, tmp_f/10.0) * 10000.0);
1601   2              }
1602   1              else if(!strcmp(param->argv[2],"rxpwr_high_warn"))
1603   1              {
1604   2                      type = RXPWR_HIGH_WARN;
1605   2                      value16 = (uint16_t)(pow(10.0, tmp_f/10.0) * 10000.0);
1606   2              }
1607   1              else if(!strcmp(param->argv[2],"rxpwr_low_warn"))
1608   1              {
1609   2                      type =RXPWR_LOW_WARN;
1610   2                      value16 = (uint16_t)(pow(10.0, tmp_f/10.0) * 10000.0);
1611   2              }
1612   1              else if(!strcmp(param->argv[2],"bias_high_alarm"))  // bias
1613   1              {
1614   2                      type = TXBIAS_HIGH_ALARM;
1615   2                      value16 = (uint16_t)(tmp_f * 1000.0 / 2.0);
1616   2              }
1617   1              else if(!strcmp(param->argv[2],"bias_low_alarm"))
1618   1              {
1619   2                      type = TXBIAS_LOW_ALARM;
1620   2                      value16 = (uint16_t)(tmp_f * 1000.0 / 2.0);
1621   2              }
1622   1              else if(!strcmp(param->argv[2],"bias_high_warn"))
1623   1              {
1624   2                      type = TXBIAS_HIGH_WARN;
1625   2                      value16 = (uint16_t)(tmp_f * 1000.0 / 2.0);
1626   2              }
1627   1              else if(!strcmp(param->argv[2],"bias_low_warn"))
1628   1              {
1629   2                      type = TXBIAS_LOW_WARN;
1630   2                      value16 = (uint16_t)(tmp_f * 1000.0 / 2.0);
1631   2              }
1632   1              else if(!strcmp(param->argv[2],"txpwr_high_alarm"))  // txpower
1633   1              {
1634   2                      type = TXPWR_HIGH_ALARM;
1635   2                      value16 = (uint16_t)(pow(10.0, tmp_f/10.0) * 10000.0);
1636   2              }
1637   1              else if(!strcmp(param->argv[2],"txpwr_low_alarm"))
1638   1              {
1639   2                      type = TXPWR_LOW_ALARM;
1640   2                      value16 = (uint16_t)(pow(10.0, tmp_f/10.0) * 10000.0);
1641   2              }
1642   1              else if(!strcmp(param->argv[2],"txpwr_high_warn"))
1643   1              {
1644   2                      type = TXPWR_HIGH_WARN;
1645   2                      value16 = (uint16_t)(pow(10.0, tmp_f/10.0) * 10000.0);
1646   2              }
1647   1              else if(!strcmp(param->argv[2],"txpwr_low_warn"))
1648   1              {
1649   2                      type = TXPWR_LOW_WARN;
1650   2                      value16 = (uint16_t)(pow(10.0, tmp_f/10.0) * 10000.0);
1651   2              }
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 28  

1652   1              else
1653   1              {
1654   2                      ret = RET_FAILED;
1655   2              }
1656   1      
1657   1              if(!strcmp(param->argv[0],"set"))
1658   1              {
1659   2                 if(value >= TEMP_HIGH_ALARM && value < HTRHLD_ALL)
1660   2                      {
1661   3                              ret = qsfp28_set_thrhld_value(type,value16);
1662   3                      }
1663   2              }
1664   1              else if(!strcmp(param->argv[0],"get"))
1665   1              {
1666   2                      ret = qsfp28_get_thrhld_value(type);
1667   2              }
1668   1      
1669   1              return ret;
1670   1      }
1671          
1672          static uint8_t _cli_module_class_cmd(PARAM_INFO_T  *param)
1673          {
1674   1              uint8_t ret = RET_OK;
1675   1      
1676   1              if(!strcmp((char*)param->argv[0],"get"))
1677   1              {
1678   2                      ret = qsfp28_get_module_class();
1679   2              }
1680   1              else if(!strcmp((char*)param->argv[0],"set"))
1681   1              {
1682   2                      uint8_t value = (uint8_t)com_str_to_int16(param->argv[2]);
1683   2      
1684   2                      ret = qsfp28_set_module_class(value);
1685   2              }
1686   1              else
1687   1              {
1688   2                      ret = RET_FAILED;
1689   2              }
1690   1              return ret;
1691   1      }
1692          
1693          static uint8_t  _cli_set_iic_cmd(PARAM_INFO_T  *param)
1694          {
1695   1              uint8_t ret = RET_OK;
1696   1      
1697   1              if(!strcmp(param->argv[0],"get"))
1698   1              {
1699   2                      uart_printf("\r\n i2c Clock Speed : %hu kHz", i2c_master_get_freq());
1700   2              }
1701   1              else if(!strcmp(param->argv[0],"set"))
1702   1              {
1703   2                      uint16_t Clock = com_str_to_int16(param->argv[2]);
1704   2      
1705   2                      if(Clock > 30)
1706   2                      {
1707   3                              i2c_master_set_freq(Clock);
1708   3                      }
1709   2                      else
1710   2                      {
1711   3                              uart_printf("%s","\r\n Minimum frequency 30kHz ");
1712   3                      }
1713   2              }
1714   1              else
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 29  

1715   1              {
1716   2                      ret = RET_FAILED;
1717   2              }
1718   1              return ret;
1719   1      }
1720          
1721          static uint8_t  _cli_get_mod_boot_reason_cmd(PARAM_INFO_T  *param)
1722          {
1723   1              uint8_t ret = RET_OK;
1724   1              uint8_t value = 0;
1725   1      
1726   1              if(!strcmp(param->argv[0],"get"))
1727   1              {
1728   2              ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, SFP_PAGE_04H);
1729   2              JUDGE_RETURN(ret);
1730   2                      ret = i2c_master_read_byte(I2C_DEVICE_ADDR, SFP_MOD_BOOT_REASON, &value);
1731   2                      if(value == 0x03)
1732   2                      {
1733   3                              uart_printf("%s","\r\n Module state is normal");
1734   3                      }
1735   2                      else
1736   2                      {
1737   3                              uart_printf("%s","\r\n Module Watch Dog reboot");
1738   3                      }
1739   2              }
1740   1              else
1741   1              {
1742   2                      ret = RET_FAILED;
1743   2              }
1744   1              return ret;
1745   1      }
1746          
1747          static void _rssi_poll_timer_handle(void)
1748          {
1749   1              uart_put_string("\r\n111");
1750   1      }
1751          
1752          static void _intl_get_ddmi_data_timer_handle()
1753          {
1754   1              uart_put_string("\r\n222");
1755   1      }
1756          
1757          static void _prbs_code_timer_handle(void)  //1000ms 
1758          {
1759   1              uart_put_string("\r\n333");
1760   1      }
1761          
1762          static RETURN_VALUE_TYPE prvDispConfigRssiConfig(PARAM_INFO_T  *param)
1763          {
1764   1              uint8_t ret = RET_OK;
1765   1      
1766   1              if(!strcmp(param->argv[1],"show"))
1767   1              {
1768   2                      int16_t num = (int16_t)com_str_to_int16(param->argv[2]);
1769   2      
1770   2                      if(num > 0 && num <= 30000)
1771   2                      {
1772   3                              rssi_poll_timer.timeout = num;
1773   3                      }
1774   2                      else
1775   2                      {
1776   3                              rssi_poll_timer.timeout = 500;
1777   3                      }
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 30  

1778   2      
1779   2                      timer_start(&rssi_poll_timer);
1780   2              }
1781   1              else if(!strcmp(param->argv[1],"stop"))
1782   1              {
1783   2                      timer_stop(&rssi_poll_timer);
1784   2              }
1785   1              else
1786   1              {
1787   2                      ret = RET_FAILED;
1788   2              }
1789   1      
1790   1              return ret;
1791   1      }
1792          
1793          static RETURN_VALUE_TYPE prvDispAutoAbleConfig(PARAM_INFO_T  *param)//auto enable|disable
1794          {
1795   1              if(!strcmp(param->argv[1],"enable"))
1796   1              {
1797   2                      return qsfp28_msa_page4_dbg_cmd(DBG_AUTO_ENABLE_CMD);
1798   2              }
1799   1              else
1800   1              {
1801   2                      return qsfp28_msa_page4_dbg_cmd(DBG_AUTO_DISABLE_CMD);
1802   2              }
1803   1      }
1804          
1805          static RETURN_VALUE_TYPE prvDispDdmiAbleConfig(PARAM_INFO_T  *param) //ddmi enable|disable
1806          {
1807   1              if(!strcmp(param->argv[1],"enable"))
1808   1              {
1809   2                      return qsfp28_msa_page4_dbg_cmd(DBG_DDMI_ENABLE_CMD);
1810   2              }
1811   1              else
1812   1              {
1813   2                      return qsfp28_msa_page4_dbg_cmd(DBG_DDMI_DISABLE_CMD);
1814   2              }
1815   1      }
1816          
1817          static RETURN_VALUE_TYPE prvDispTxcdrRxcdrI2cEnableConfig(PARAM_INFO_T  *param) //[txcdr|rxcdr] i2c enable
1818          {
1819   1              if(!strcmp(param->argv[0],"txcdr"))
1820   1              {
1821   2                      return qsfp28_msa_page4_dbg_cmd(DBG_I2C_TXCDR_ENABLE);
1822   2              }
1823   1              else if(!strcmp(param->argv[0],"rxcdr"))
1824   1              {
1825   2                      return qsfp28_msa_page4_dbg_cmd(DBG_I2C_RXCDR_ENABLE);
1826   2              }
1827   1              else
1828   1              {
1829   2                      return RET_FAILED;
1830   2              }
1831   1      }
1832          
1833          static RETURN_VALUE_TYPE prvDispUpgdConfig() //upgd
1834          {
1835   1              return qsfp28_msa_page4_dbg_cmd(DBG_JUMP_TO_BOOT_CMD);
1836   1      }
1837          
1838          static RETURN_VALUE_TYPE prvDispAgingConfig(PARAM_INFO_T  *param) //aging [start|stop|clean]
1839          {
1840   1              if(!strcmp(param->argv[1],"start"))
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 31  

1841   1              {
1842   2                      return qsfp28_msa_page4_dbg_cmd(DBG_AGING_START_CMD);
1843   2              }
1844   1              else if(!strcmp(param->argv[1],"stop"))
1845   1              {
1846   2                      return qsfp28_msa_page4_dbg_cmd(DBG_AGING_STOP_CMD);
1847   2              }
1848   1              else// if(!strcmp(param->argv[1],"clear") )
1849   1              {
1850   2                      return qsfp28_msa_page4_dbg_cmd(DBG_AGING_EEP_INIT_CMD);
1851   2              }
1852   1      }
1853          
1854          static RETURN_VALUE_TYPE prvIntlOutputConfig(PARAM_INFO_T  *param) //intl output [enable|disable]
1855          {
1856   1              uint8_t ret = RET_OK;
1857   1      
1858   1              if(!strcmp(param->argv[2],"enable"))
1859   1              {
1860   2                      timer_start(&intl_trigger_timer);
1861   2                      port_match_all_interrupt_enable(1);
1862   2              }
1863   1              else if(!strcmp(param->argv[2],"disable"))
1864   1              {
1865   2                      timer_stop(&intl_trigger_timer);
1866   2                      port_match_all_interrupt_enable(0);
1867   2              }
1868   1              else
1869   1              {
1870   2                      ret = RET_FAILED;
1871   2              }
1872   1      
1873   1              return ret;
1874   1      }
1875          
1876          static RETURN_VALUE_TYPE prvDispLutConfig(PARAM_INFO_T  *param) //[get|set] [ch0|ch1|ch2|ch3|all] [lt|rt|h
             -t|lut] #temp #bias #mod #cross
1877          {
1878   1              if (!strcmp(param->argv[2],"lt"))  //set|get [ch1|ch2|ch3|ch4|all] lt temp bias mod cross
1879   1              {
1880   2                      return _cli_set_lut_tab(PART_LUT_INFO, MSA_LUT_TYPE_LOW_TEMP, param);
1881   2              }
1882   1              else if (!strcmp(param->argv[2],"rt"))  //set|get [ch1|ch2|ch3|ch4|all] rt temp bias mod cross
1883   1              {
1884   2                      return _cli_set_lut_tab(PART_LUT_INFO, MSA_LUT_TYPE_MID_TEMP, param);
1885   2              }
1886   1              else if (!strcmp(param->argv[2],"ht"))  //set|get [ch1|ch2|ch3|ch4|all] ht temp bias mod cross
1887   1              {
1888   2                      return _cli_set_lut_tab(PART_LUT_INFO, MSA_LUT_TYPE_HI_TEMP, param);
1889   2              }
1890   1              else if (!strcmp(param->argv[2],"lut"))  //get all lut
1891   1              {
1892   2                      return  _cli_get_all_lut_tab();
1893   2              }
1894   1              else
1895   1              {
1896   2                      return  RET_FAILED;
1897   2              }
1898   1      }
1899          
1900          uint8_t M37049_tx_cdr_prbs_cmd(PARAM_INFO_T  *param) //"set [ch0|ch1|ch2|ch3|all] tx_prbs [enable|disable]
             -"
1901          {
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 32  

1902   1              uint8_t ret = RET_OK, channel = 0;
1903   1              uint8_t ch[] = {CHANNEL2,CHANNEL1,CHANNEL3,CHANNEL0,CHANNEL_MAX};
1904   1      
1905   1              ret = ((RET_FAILED == (channel = _qsfp28_get_channel(param->argv[1]))) ? RET_FAILED : RET_OK);
1906   1      
1907   1              channel = ch[channel];
1908   1      
1909   1              if (!strcmp(param->argv[3],"enable"))
1910   1              {
1911   2                      //ret = M37049_txcdr_prbs_enable(channel);
1912   2              }
1913   1              else if(!strcmp(param->argv[3],"disable"))
1914   1              {
1915   2                      //ret = M37049_txcdr_prbs_disable(channel);
1916   2              }
1917   1              return ret;
1918   1      }
1919          
1920          uint8_t M37046_rx_cdr_prbs_pn_normal_cmd(PARAM_INFO_T  *param) //"set [ch0|ch1|ch2|ch3|all] rx_prbs check 
             -[enable|disable] #value(ms)"
1921          {
1922   1              uint8_t ret = RET_OK, channel = 0;
1923   1              uint8_t ch[] = {CHANNEL1,CHANNEL2,CHANNEL0,CHANNEL3,CHANNEL_MAX};
1924   1      
1925   1              ret = ((RET_FAILED == (channel = _qsfp28_get_channel(param->argv[1]))) ? RET_FAILED : RET_OK);
1926   1      
1927   1              channel = ch[channel];
1928   1      
1929   1              if (!strcmp(param->argv[4],"enable"))
1930   1              {
1931   2                      int16_t num = (int16_t)com_str_to_int16(param->argv[5]);
1932   2      
1933   2                      if(num > 0 && num <= 30000)
1934   2                      {
1935   3                              prbs_code_timer.timeout = num;
1936   3                      }
1937   2                      else
1938   2                      {
1939   3                              prbs_code_timer.timeout = 1000;
1940   3                      }
1941   2      
1942   2                      timer_start(&prbs_code_timer);
1943   2                      //return M37046_rxcdr_prbs_enable(channel, PN_NORMAL);
1944   2              }
1945   1              else if(!strcmp(param->argv[4],"disable"))
1946   1              {
1947   2                      timer_stop(&prbs_code_timer);
1948   2                      //return M37046_rxcdr_prbs_disable(channel);
1949   2              }
1950   1              return RET_FAILED;
1951   1      }
1952          
1953          uint8_t M37046_rx_cdr_prbs_pn_inverse_cmd(PARAM_INFO_T  *param) //"set [ch0|ch1|ch2|ch3|all] rx_prbs check
             - inverse [enable|disable] #value(ms)"
1954          {
1955   1              uint8_t ret = RET_OK, channel = 0;
1956   1              uint8_t ch[] = {CHANNEL1,CHANNEL2,CHANNEL0,CHANNEL3,CHANNEL_MAX};
1957   1      
1958   1              ret = ((RET_FAILED == (channel = _qsfp28_get_channel(param->argv[1]))) ? RET_FAILED : RET_OK);
1959   1      
1960   1              channel = ch[channel];
1961   1      
1962   1              if (!strcmp(param->argv[5],"enable"))
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 33  

1963   1              {
1964   2                      int16_t num = (int16_t)com_str_to_int16(param->argv[6]);
1965   2      
1966   2                      if(num > 0 && num <= 30000)
1967   2                      {
1968   3                              prbs_code_timer.timeout = num;
1969   3                      }
1970   2                      else
1971   2                      {
1972   3                              prbs_code_timer.timeout = 1000;
1973   3                      }
1974   2      
1975   2                      timer_start(&prbs_code_timer);
1976   2                      //ret = M37046_rxcdr_prbs_enable(channel, PN_INVERSE);
1977   2              }
1978   1              else if(!strcmp(param->argv[5],"disable"))
1979   1              {
1980   2                      timer_stop(&prbs_code_timer);
1981   2                      //ret = M37046_rxcdr_prbs_disable(channel);
1982   2              }
1983   1              return ret;
1984   1      }
1985          
1986          static RETURN_VALUE_TYPE prvDispshowReg(PARAM_INFO_T  *param) //ddmi enable|disable
1987          {
1988   1              param = NULL;
1989   1              reg_add_show("P0", P0, 0x00);
1990   1              reg_add_show("P1", P1, 0x00);
1991   1              reg_add_show("P2", P2, 0x00);
1992   1              reg_add_show("P3", P3, 0x00);
1993   1      
1994   1              reg_add_show("P0MDOUT", P0MDOUT, 0x20);
1995   1              reg_add_show("P1MDOUT", P1MDOUT, 0x20);
1996   1              reg_add_show("P2MDOUT", P2MDOUT, 0x20);
1997   1              reg_add_show("P3MDOUT", P3MDOUT, 0x20);
1998   1      
1999   1              reg_add_show("P0MDIN", P0MDIN,  0x20);
2000   1              reg_add_show("P1MDIN", P1MDIN,  0x20);
2001   1              reg_add_show("P2MDIN", P2MDIN,  0x20);
2002   1              reg_add_show("P3MDIN", P3MDIN,  0x20);
2003   1      
2004   1              return RET_OK;
2005   1      }
2006          
2007          static RETURN_VALUE_TYPE prvDispReadWriteReg(PARAM_INFO_T  *param) //ddmi enable|disable
2008          {
2009   1              int16_t num = 0;
2010   1      
2011   1              if (!strcmp(param->argv[0],"read"))  //read reg P0
2012   1              {
2013   2                      if (!strcmp(param->argv[1],"reg"))
2014   2                      {
2015   3                              printf("\r\n%s\t = 0x%bx", param->argv[2], reg_read(param->argv[2]));
2016   3                      }
2017   2              }
2018   1              else if (!strcmp(param->argv[0],"write"))  //write reg  P0 0x33
2019   1              {
2020   2                      if (!strcmp(param->argv[1],"reg"))
2021   2                      {
2022   3                              num = (int16_t)com_str_to_int16(param->argv[3]);
2023   3                              reg_write(param->argv[2], (MCU_BIT_WIDTH_T)num);
2024   3                      }
2025   2              }
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 34  

2026   1      
2027   1      
2028   1              return RET_OK;
2029   1      }
2030          void cmd_init()
2031          {
2032   1              prbs_code_timer.function = _rssi_poll_timer_handle;
2033   1              prbs_code_timer.timeout  = 1000;
2034   1      
2035   1              timer_add(&prbs_code_timer);
2036   1      
2037   1              rssi_poll_timer.function = _prbs_code_timer_handle;
2038   1              rssi_poll_timer.timeout  = 2000;
2039   1              timer_add(&rssi_poll_timer);
2040   1      
2041   1              intl_trigger_timer.function = _intl_get_ddmi_data_timer_handle;
2042   1              intl_trigger_timer.timeout  = 3000;
2043   1              timer_add(&intl_trigger_timer);
2044   1      
2045   1              terminal_register_cmd("build info"      \
2046   1                                        ,prvDispVersionConfig);
2047   1              terminal_register_cmd("reset"    \
2048   1                                        ,prvDispResetConfig);
2049   1              terminal_register_cmd("reboot"    \
2050   1                                        ,prvDispRebootConfig);
2051   1              terminal_register_cmd("factory_reset" \
2052   1                                        ,prvDispFactoryResetConfig);
2053   1              terminal_register_cmd("get swver" \
2054   1                                        ,prvDispSwverConfig);
2055   1              terminal_register_cmd("[opr|opw] &baseAddr &OffAddr #ParmNum(0~0xff)" \
2056   1                                                ,prvDispOprwConfig);
2057   1              terminal_register_cmd("[mdior|mdiow] &baseAddr &OffAddr #ParmNum(0~0xff)" \
2058   1                                                        ,prvDispMdiorwConfig);
2059   1              terminal_register_cmd("get intl" \
2060   1                                        ,prvDispInitConfig);
2061   1              terminal_register_cmd("get mod_status" \
2062   1                                        ,prvDispModStatusConfig);
2063   1              terminal_register_cmd("enter bonding" \
2064   1                                        ,prvDispBondingConfig);
2065   1              terminal_register_cmd("eep   [init|show|erase] " \
2066   1                                        ,prvDispEepConfig);
2067   1              terminal_register_cmd("auto [enable|disable]" \
2068   1                                        ,prvDispAutoAbleConfig);
2069   1              terminal_register_cmd("ddmi [enable|disable]" \
2070   1                                        ,prvDispDdmiAbleConfig);
2071   1              terminal_register_cmd("aging [start|stop|clean]" \
2072   1                                        ,prvDispAgingConfig);
2073   1              terminal_register_cmd("intl output [enable|disable]" \
2074   1                                        ,prvIntlOutputConfig);
2075   1              terminal_register_cmd("test modsel #[0|1]" \
2076   1                                        ,prvDispTestModselConfig);
2077   1              terminal_register_cmd("test modsel aborted" \
2078   1                                        ,prvDispTestModselConfig);
2079   1              terminal_register_cmd("[get|set] lpmode #[0|1]" \
2080   1                                        ,prvDispLpmodeConfig);
2081   1              terminal_register_cmd("[get|set] reset  #[0|1]" \
2082   1                                        ,prvDispgsetResetConfig);
2083   1              terminal_register_cmd("[get|set] reset_l #[0|1]" \
2084   1                                        ,prvDispgsetResetLevelConfig);
2085   1              terminal_register_cmd("[get|set] modsel #[0|1]" \
2086   1                                        ,prvDispModselConfig);
2087   1              terminal_register_cmd("enter msa download" \
2088   1                                        ,prvDispMsaDownloadConfig);
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 35  

2089   1              terminal_register_cmd("rssi [show|stop] #value(ms)" \
2090   1                                        ,prvDispConfigRssiConfig);
2091   1              terminal_register_cmd("mod_console [enable|disable]" \
2092   1                                        ,prvDispConfigModConfig);
2093   1              terminal_register_cmd("[txcdr|rxcdr] i2c enable" \
2094   1                                        ,prvDispTxcdrRxcdrI2cEnableConfig);
2095   1              terminal_register_cmd("[read|enable|disable|clear] log"    \
2096   1                                        ,prvDispLogConfig);
2097   1              terminal_register_cmd("eep regset &devaddr &offsetaddr &value" \
2098   1                                        ,prvDispEepConfig);
2099   1              terminal_register_cmd("[oprt|opwt] &baseAddr &OffAddr #ParmNum(0~0xff)" \
2100   1                                        ,prvDispOprwConfig);
2101   1              terminal_register_cmd("[get|set] laser_tx_sn #" \
2102   1                                        ,_cli_laser_tx_sn_cmd);
2103   1              terminal_register_cmd("[get|set] laser_rx_sn #" \
2104   1                                        ,_cli_laser_rx_sn_cmd);
2105   1              terminal_register_cmd("[get|set] pic_code #" \
2106   1                                        ,_cli_pic_code_cmd);
2107   1              terminal_register_cmd("[get|set] module_type #[0x101|0x206|0x211|0x301]" \
2108   1                                        ,_cli_module_type_cmd);
2109   1              terminal_register_cmd("[get|set] hw_ver #value(AM)" \
2110   1                                        ,_cli_hw_ver_cmd);
2111   1              terminal_register_cmd("[get|set] vendor_pn  #char[16]" \
2112   1                                        ,prvDispVendorPnConfig);
2113   1              terminal_register_cmd("[get|set] vendor_rev #char[2]"  \
2114   1                                        ,prvDispVendorRevConfig);
2115   1              terminal_register_cmd("[get|set] vendor_sn  #char[16]" \
2116   1                                        ,prvDispVendorSnConfig);
2117   1              terminal_register_cmd("[get|set] date_code  #char[8]"  \
2118   1                                        ,prvDispDateCodeConfig);
2119   1              terminal_register_cmd("[get|set] supercode  #char[9]"  \
2120   1                                        ,prvDispSuperCodeConfig);
2121   1              terminal_register_cmd("[get|set] pcba_sn    #char[16]" \
2122   1                                        ,prvDispPcbaSnConfig);
2123   1              terminal_register_cmd("[get|set] pcba_code  #char[16]" \
2124   1                                        ,prvDispPcbaCodeConfig);
2125   1              terminal_register_cmd("get module [vcc|temp|bias|txpower|rxpower] #channel" \
2126   1                                        ,prvDispModuleConfig);
2127   1              terminal_register_cmd("[get|set] [ch0|ch1|ch2|ch3|all] [lt|rt|ht|lut] #temp #bias #mod #cross" \
2128   1                                        ,prvDispLutConfig);
2129   1              terminal_register_cmd("[get|set] [ch0|ch1|ch2|ch3] #[cur|fixed_temp] lut tab" \
2130   1                                        ,prvDispLuttabConfig);
2131   1              terminal_register_cmd("[set|get] ddmi_cali [temp_offset|vcc_offset] #value" \
2132   1                                        ,_cli_ddmi_cali);
2133   1              terminal_register_cmd("[set|get] ddmi_cali [ch0|ch1|ch2|ch3|all] bias_offset #BIAS_X #BIAS_Y" \
2134   1                                        ,_cli_ddmi_cali);
2135   1              terminal_register_cmd("[set|get] ddmi_cali [ch0|ch1|ch2|ch3] txpwr #TXPWR1 #BIAS1 #TXPWR2 #BIAS2" \
2136   1                                        ,_cli_ddmi_cali);
2137   1              terminal_register_cmd("[set|get] ddmi_cali [ch0|ch1|ch2|ch3] rxpwr #RXPWR1 #RSSI1 #RXPWR2 #RSSI2" \
2138   1                                        ,_cli_ddmi_cali);
2139   1              terminal_register_cmd("get ddmi [vcc|temp]" \
2140   1                                        ,_cli_ddmi_cmd);
2141   1              terminal_register_cmd("get ddmi [bias|txmon|rssi] [0|1|2|3]" \
2142   1                                        ,_cli_ddmi_cmd);
2143   1              terminal_register_cmd("[set|get] thrhld [temp_high_alarm|temp_high_warn|temp_low_alarm|temp_low_warn] #va
             -lue" \
2144   1                                        ,_cli_thrhld_cmd);
2145   1              terminal_register_cmd("[set|get] thrhld [vcc_high_alarm|vcc_high_warn|vcc_low_alarm|vcc_low_warn]     #va
             -lue" \
2146   1                                        ,_cli_thrhld_cmd);
2147   1              terminal_register_cmd("[set|get] thrhld [bias_high_alarm|bias_high_warn|bias_low_alarm|bias_low_warn] #va
             -lue" \
2148   1                                        ,_cli_thrhld_cmd);
C51 COMPILER V9.53.0.0   EFM8LB12_CMD                                                      10/09/2019 13:50:13 PAGE 36  

2149   1              terminal_register_cmd("[set|get] thrhld [rxpwr_high_alarm|rxpwr_high_warn|rxpwr_low_alarm|rxpwr_low_warn]
             - #value" \
2150   1                                    ,_cli_thrhld_cmd);
2151   1              terminal_register_cmd("[set|get] thrhld [txpwr_high_alarm|txpwr_high_warn|txpwr_low_alarm|txpwr_low_warn]
             - #value" \
2152   1                                ,_cli_thrhld_cmd);
2153   1              terminal_register_cmd("[get|set] module_class #value" \
2154   1                                        ,_cli_module_class_cmd);
2155   1              terminal_register_cmd("[set|get] iic_speed #value(kHz)" \
2156   1                                        ,_cli_set_iic_cmd);
2157   1              terminal_register_cmd("get mod_boot_reason" \
2158   1                                        ,_cli_get_mod_boot_reason_cmd);
2159   1              terminal_register_cmd("set [ch0|ch1|ch2|ch3|all] tx_prbs [enable|disable]" \
2160   1                                        ,M37049_tx_cdr_prbs_cmd);
2161   1              terminal_register_cmd("set [ch0|ch1|ch2|ch3|all] rx_prbs check [enable|disable] #value(ms)" \
2162   1                                        ,M37046_rx_cdr_prbs_pn_normal_cmd);
2163   1              terminal_register_cmd("set [ch0|ch1|ch2|ch3|all] rx_prbs invert check [enable|disable] #value(ms)" \
2164   1                                        ,M37046_rx_cdr_prbs_pn_inverse_cmd);
2165   1              terminal_register_cmd("set [ch0|ch1|ch2|ch3|all] tx [enable|disable]" \
2166   1                                        ,_cli_tx_laser_cmd);
2167   1              terminal_register_cmd("get [ch0|ch1|ch2|ch3|all] tx" \
2168   1                                        ,_cli_tx_laser_cmd);
2169   1              terminal_register_cmd("[get|set] [ch0|ch1|ch2|ch3|all] darka_thld #value(uA)" \
2170   1                                        ,_cli_rssi_darka_cmd);
2171   1              terminal_register_cmd("[get|set] [ch0|ch1|ch2|ch3|all] darkd_thld #value(uA)" \
2172   1                                        ,_cli_rssi_darkd_cmd);
2173   1              terminal_register_cmd("[get|set] [ch0|ch1|ch2|ch3] losa_thld #value(uA)" \
2174   1                                        ,_cli_rx_losa_cmd);
2175   1              terminal_register_cmd("[get|set] [ch0|ch1|ch2|ch3] losd_thld #value(uA)" \
2176   1                                        ,_cli_rx_losd_cmd);
2177   1              terminal_register_cmd("show mcu reg" \
2178   1                                        ,prvDispshowReg);
2179   1              terminal_register_cmd("[read|write] reg &reg_name #value" \
2180   1                                        ,prvDispReadWriteReg);
2181   1      }
2182          
2183          
2184          
2185          
2186          
2187          
2188          
2189          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  13235    ----
   CONSTANT SIZE    =   5028    ----
   XDATA SIZE       =     39     918
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
