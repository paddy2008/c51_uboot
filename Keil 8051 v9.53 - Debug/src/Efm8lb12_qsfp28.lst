C51 COMPILER V9.53.0.0   EFM8LB12_QSFP28                                                   10/14/2019 10:20:30 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE EFM8LB12_QSFP28
OBJECT MODULE PLACED IN .\src\Efm8lb12_qsfp28.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v3\developer\toolchains\keil_8051\9.53\BIN\C51.exe D:\Work Project\
                    -SingleChipWorkSpaveNew\C51_UBOOT\src\Efm8lb12_qsfp28.c OMF2 LARGE DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZ
                    -ZY(3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(D:/Work Project/SingleChipWorkSpaveNew/C51_U
                    -BOOT/inc;D:/Work Project/SingleChipWorkSpaveNew/C51_UBOOT/mcu_sal_lib;C:/SiliconLabs/SimplicityStudio/v3/developer/sdks/
                    -si8051/v3//Device/shared/si8051Base;C:/SiliconLabs/SimplicityStudio/v3/developer/sdks/si8051/v3//Device/EFM8LB1/inc;C:/S
                    -iliconLabs/SimplicityStudio/v3/developer/sdks/si8051/v3//Lib/efm8_assert;C:/SiliconLabs/SimplicityStudio/v3/developer/sd
                    -ks/si8051/v3//Lib/efm8lb1;C:/SiliconLabs/SimplicityStudio/v3/developer/sdks/si8051/v3//Device/EFM8LB1;C:/SiliconLabs/Sim
                    -plicityStudio/v3/developer/sdks/si8051/v3//Device/EFM8LB1/peripheral_driver/inc) PRINT(.\src\Efm8lb12_qsfp28.lst) COND P
                    -AGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\Efm8lb12_qsfp28.OBJ)

line level    source

   1          #include "Efm8lb12_qsfp28.h"
   2          #include "Efm8lb12_cmd.h"
   3          #include "mcu_sal.h"
   4          
   5          
   6          static uint8_t _mod_type         = INVALID;
   7          static uint8_t _mod_sub_type = INVALID;
   8          static uint8_t _mod_hw_rev   = INVALID;
   9          
  10          static POLL_T poll = {0};
  11          
  12          static MSA_PAGE_LOWER_MON_T _lower_mon = {0};
  13          
  14          const uint8_t lut_page_select[MSA_LUT_TYPE_MAX] = {SFP_PAGE_06H, SFP_PAGE_06H, SFP_PAGE_07H};
  15          const uint8_t lut_temp_select[MSA_LUT_TYPE_MAX] = {LUT_LT_TEMP_MSB, LUT_MT_TEMP_MSB, LUT_HT_TEMP_MSB};
  16          
  17          uint8_t smb_write_page_byte(uint8_t BaseAddr, uint8_t page, uint16_t OffsetAddr,uint8_t *Data, uint16_t Le
             -ngth)
  18          {
  19   1              uint8_t ret = RET_FAILED;
  20   1      
  21   1              ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, page);
  22   1              JUDGE_RETURN(ret);
  23   1              ret = i2c_master_write(BaseAddr, OffsetAddr, Data, Length);
  24   1              return ret;
  25   1      }
  26          
  27          uint8_t smb_read_page_byte(uint8_t BaseAddr, uint8_t page, uint16_t OffsetAddr,uint8_t *Data, uint16_t Len
             -gth)
  28          {
  29   1              uint8_t ret = RET_FAILED;
  30   1      
  31   1              ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, page);
  32   1              JUDGE_RETURN(ret);
  33   1              ret = i2c_master_read(BaseAddr, OffsetAddr, Data, Length);
  34   1              return ret;
  35   1      }
  36          
  37          
  38          const uint8_t lut_laser_cfg_select[MSA_LUT_TYPE_MAX][CHANNEL_MAX] =
  39          {
  40                  {PAGE6_LT_CH0_LASER_CFG_BASE_ADDR, PAGE6_LT_CH1_LASER_CFG_BASE_ADDR, PAGE6_LT_CH2_LASER_CFG_BASE_ADDR, PA
             -GE6_LT_CH3_LASER_CFG_BASE_ADDR},
  41                  {PAGE6_MT_CH0_LASER_CFG_BASE_ADDR, PAGE6_MT_CH1_LASER_CFG_BASE_ADDR, PAGE6_MT_CH2_LASER_CFG_BASE_ADDR, PA
             -GE6_MT_CH3_LASER_CFG_BASE_ADDR},
  42                  {PAGE7_HT_CH0_LASER_CFG_BASE_ADDR, PAGE7_HT_CH1_LASER_CFG_BASE_ADDR, PAGE7_HT_CH2_LASER_CFG_BASE_ADDR, PA
             -GE7_HT_CH3_LASER_CFG_BASE_ADDR}
  43          };
C51 COMPILER V9.53.0.0   EFM8LB12_QSFP28                                                   10/14/2019 10:20:30 PAGE 2   

  44          
  45          const uint8_t page3_alarm_wran_select[] =
  46          {
  47                  PAGE3_TEMP_HIGH_ALARM_MSB  , PAGE3_TEMP_LOW_ALARM_MSB  , PAGE3_TEMP_HIGH_WARN_MSB  , PAGE3_TEMP_LOW_WARN_
             -MSB ,
  48                  PAGE3_VCC_HIGH_ALARM_MSB   , PAGE3_VCC_LOW_ALARM_MSB   , PAGE3_VCC_HIGH_WARN_MSB   , PAGE3_VCC_LOW_WARN_M
             -SB   ,
  49                  PAGE3_RXPWR_HIGH_ALARM_MSB , PAGE3_RXPWR_LOW_ALARM_MSB , PAGE3_RXPWR_HIGH_WARN_MSB , PAGE3_RXPWR_LOW_WARN
             -_MSB ,
  50                  PAGE3_TXBIAS_HIGH_ALARM_MSB, PAGE3_TXBIAS_LOW_ALARM_MSB, PAGE3_TXBIAS_HIGH_WARN_MSB, PAGE3_TXBIAS_LOW_WAR
             -N_MSB,
  51                  PAGE3_TXPWR_HIGH_ALARM_MSB , PAGE3_TXPWR_LOW_ALARM_MSB , PAGE3_TXPWR_HIGH_WARN_MSB , PAGE3_TXPWR_LOW_WARN
             -_MSB
  52          };
  53          
  54          uint8_t _qsfp28_get_channel(const char  *s)
  55          {
  56   1              uint8_t channel = -1;
  57   1      
  58   1              if (!strcmp(s, "ch0"))
  59   1              {
  60   2                      channel = CHANNEL0;
  61   2              }
  62   1              else if (!strcmp(s, "ch1"))
  63   1              {
  64   2                      channel = CHANNEL1;
  65   2              }
  66   1              else if (!strcmp(s, "ch2"))
  67   1              {
  68   2                      channel = CHANNEL2;
  69   2              }
  70   1              else if (!strcmp(s, "ch3"))
  71   1              {
  72   2                      channel = CHANNEL3;
  73   2              }
  74   1              else if (!strcmp(s, "all"))
  75   1              {
  76   2                      channel = CHANNEL_MAX;
  77   2              }
  78   1              else
  79   1              {
  80   2                      channel = RET_FAILED;
  81   2                      uart_printf("\r\nchannedl%bu is not support\r\n",channel);
  82   2              }
  83   1              return channel;
  84   1      }
  85          
  86          static uint16_t _com_int_pow(uint8_t m, uint8_t n)
  87          {
  88   1              uint8_t i = 0;
  89   1              uint16_t result = 1;
  90   1      
  91   1              for ( i = 0; i < n; i++)
  92   1              {
  93   2                      result *= m;
  94   2              }
  95   1              return result;
  96   1      }
  97          
  98          int16_t com_str_to_int16(uint8_t *str)
  99          {
 100   1              idata uint8_t  *ptr = str, i = 0, len = 0, tmp[5];
 101   1              idata int16_t  temp = 0;
C51 COMPILER V9.53.0.0   EFM8LB12_QSFP28                                                   10/14/2019 10:20:30 PAGE 3   

 102   1              bool IsHex = false;
 103   1      
 104   1              memset(tmp,'\0',5);
 105   1      
 106   1              if ((strchr(str,'x') != NULL) || (strchr(str,'X') != NULL))
 107   1              {
 108   2                      IsHex = true;
 109   2                      ptr += 2;
 110   2                      for (i = 0; i < 4 ; i++)
 111   2                      {
 112   3                              tmp[i] = *ptr;
 113   3                              ptr++;
 114   3                      }
 115   2                      ptr = tmp;
 116   2              }
 117   1              else
 118   1              {
 119   2                      ptr = str;
 120   2              }
 121   1      
 122   1              if (IsHex)
 123   1              {
 124   2                      len = strlen(ptr);
 125   2                      for (i = 0; i < len; i++)
 126   2                      {
 127   3                              if (*ptr >= '0' && *ptr <= '9')
 128   3                              {
 129   4                                      temp += (*ptr-'0') * _com_int_pow(16,len-1-i);
 130   4                              }
 131   3                              else if (*ptr >= 'a' && *ptr <= 'f')
 132   3                              {
 133   4                                      temp += (*ptr-'a'+ 10) * _com_int_pow(16,len-1-i);
 134   4                              }
 135   3                              else if (*ptr >= 'A' && *ptr <= 'F')
 136   3                              {
 137   4                                      temp += (*ptr-'A' + 10) * _com_int_pow(16,len-1-i);
 138   4                              }
 139   3                              ptr++;
 140   3                      }
 141   2              }
 142   1              else
 143   1              {
 144   2                      temp = (int16_t)atoi(ptr);
 145   2              }
 146   1      
 147   1              return temp;
 148   1      }
 149          
 150          void com_delay(uint16_t sec)
 151          {
 152   1              timer_delay_ms(sec);
 153   1      }
 154          
 155          void com_delay_us(uint8_t us)   //excute one time is 72 clock cycles
 156          {
 157   1              uint8_t i = 0;
 158   1      
 159   1              for(i = 0; i < us; i++)
 160   1              {
 161   2                      _nop_();
 162   2      
 163   2                      _nop_();
 164   2                      _nop_();
C51 COMPILER V9.53.0.0   EFM8LB12_QSFP28                                                   10/14/2019 10:20:30 PAGE 4   

 165   2                      _nop_();
 166   2                      _nop_();
 167   2                      _nop_();
 168   2                      _nop_();
 169   2                      _nop_();
 170   2                      _nop_();
 171   2                      _nop_();
 172   2                      _nop_();
 173   2      
 174   2                      _nop_();
 175   2                      _nop_();
 176   2                      _nop_();
 177   2                      _nop_();
 178   2                      _nop_();
 179   2                      _nop_();
 180   2                      _nop_();
 181   2                      _nop_();
 182   2                      _nop_();
 183   2                      _nop_();
 184   2      
 185   2                      _nop_();
 186   2                      _nop_();
 187   2                      _nop_();
 188   2                      _nop_();
 189   2                      _nop_();
 190   2                      _nop_();
 191   2                      _nop_();
 192   2                      _nop_();
 193   2                      _nop_();
 194   2                      _nop_();
 195   2      
 196   2                      _nop_();
 197   2                      _nop_();
 198   2                      _nop_();
 199   2                      _nop_();
 200   2                      _nop_();
 201   2                      _nop_();
 202   2                      _nop_();
 203   2                      _nop_();
 204   2                      _nop_();
 205   2                      _nop_();
 206   2      
 207   2                      _nop_();
 208   2                      _nop_();
 209   2                      _nop_();
 210   2                      _nop_();
 211   2                      _nop_();
 212   2                      _nop_();
 213   2                      _nop_();
 214   2                      _nop_();
 215   2                      _nop_();
 216   2                      _nop_();
 217   2      
 218   2      
 219   2                      _nop_();
 220   2                      _nop_();
 221   2                      _nop_();
 222   2                      _nop_();
 223   2                      _nop_();
 224   2                      _nop_();
 225   2                      _nop_();
 226   2                      _nop_();
 227   2              }
C51 COMPILER V9.53.0.0   EFM8LB12_QSFP28                                                   10/14/2019 10:20:30 PAGE 5   

 228   1      }
 229          
 230          bool com_get_module_boot_status()
 231          {
 232   1              uint8_t value = 1, i = 0;
 233   1      
 234   1              for(i = 0; i < 20; i++)
 235   1              {
 236   2                      value = 1;
 237   2                      if(RET_OK == i2c_master_read_byte(I2C_DEVICE_ADDR, MSA_BOOT_STATUS, &value))
 238   2                      {
 239   3                              if(MY_GET_BIT(value, 0) != 0x0) //equal to 0 indicate the module boot success
 240   3                              {
 241   4                                      break;
 242   4                              }
 243   3                      }
 244   2              }
 245   1      
 246   1              if(i == 20)
 247   1              {
 248   2                      return true;
 249   2              }
 250   1      
 251   1              return false;
 252   1      }
 253          
 254          bool com_test_board_pre_handle()
 255          {
 256   1              if(com_get_module_boot_status())
 257   1              {
 258   2                      uart_printf("%s","\r\nModule boot success");
 259   2                      uart_printf("%s","\r\n#McuTestBoard:");
 260   2                      return true;
 261   2              }
 262   1              else
 263   1              {
 264   2                      uart_printf("%s","\r\nModule boot error");
 265   2                      return false;
 266   2              }
 267   1      
 268   1      }
 269          
 270          uint16_t com_average_value16(uint16_t *buffer, uint8_t length)
 271          {
 272   1              uint8_t  i  = 0;
 273   1              uint16_t max = 0, min = 0;
 274   1              uint32_t sum = 0;
 275   1      
 276   1              max = buffer[0];
 277   1              min = buffer[0];
 278   1      
 279   1              for(i = 0; i < length; i++)
 280   1              {
 281   2                      if(buffer[i] > max)
 282   2                      {
 283   3                              max = buffer[i];
 284   3                      }
 285   2      
 286   2                      if(buffer[i] < min)
 287   2                      {
 288   3                              min = buffer[i];
 289   3                      }
 290   2                      sum += buffer[i];
C51 COMPILER V9.53.0.0   EFM8LB12_QSFP28                                                   10/14/2019 10:20:30 PAGE 6   

 291   2              }
 292   1      
 293   1              sum = sum - min - max;
 294   1      
 295   1              return (uint16_t)(sum / (length -2));
 296   1      }
 297          
 298          
 299          
 300          
 301          bool qsfp28_get_cmd_status()
 302          {
 303   1              uint8_t  cmd_ret_status = 0;
 304   1              uint16_t counter = 0;
 305   1      
 306   1              do
 307   1              {
 308   2                      i2c_master_read_byte(I2C_DEVICE_ADDR, SFP_DBG_CMD, &cmd_ret_status);
 309   2                      counter ++;
 310   2                      timer_delay_ms(2 * counter);
 311   2                      if(counter >= 100)  //delay 10s
 312   2                      {
 313   3                              uart_printf("\r\nQsfp28_get_cmd_status failed");
 314   3                              return false;
 315   3                      }
 316   2      
 317   2              }while(cmd_ret_status != RET_OK && cmd_ret_status != RET_FAILED);
 318   1      
 319   1              i2c_master_write_byte(I2C_DEVICE_ADDR, SFP_DBG_CMD, SFP_DBG_CMD_IDLE);  //set dbg_cmd_status idle
 320   1      
 321   1              if(cmd_ret_status == RET_FAILED)
 322   1              {
 323   2                      return false;
 324   2              }
 325   1              else
 326   1              {
 327   2                      return true;
 328   2              }
 329   1      }
 330          
 331          static char * qsfp28_get_mod_name(char *name)
 332          {
 333   1              switch(_mod_type) {
 334   2                      case MODULE_TYPE_SR4:
 335   2                              sprintf(name, "SR4-%bx%02bx", _mod_type, _mod_sub_type);
 336   2                              break;
 337   2                      case MODULE_TYPE_CWDM4:
 338   2                              sprintf(name, "CWDM4-%bx%02bx", _mod_type, _mod_sub_type);
 339   2                              break;
 340   2                      case MODULE_TYPE_LR4:
 341   2                              sprintf(name, "LR4-%bx%02bx", _mod_type, _mod_sub_type);
 342   2                              break;
 343   2                      default:
 344   2                              sprintf(name, "UNKNOWN");
 345   2                              break;
 346   2              }
 347   1              return name;
 348   1      }
 349          
 350          uint8_t qsfp28_common_rssi_show()
 351          {
 352   1              uint16_t rssi_ua[4];
 353   1      
C51 COMPILER V9.53.0.0   EFM8LB12_QSFP28                                                   10/14/2019 10:20:30 PAGE 7   

 354   1              uint8_t rssi_addr[] = {0x86, 0x92, 0x9E, 0xAA} ,channel = 0 , ret = RET_OK;
 355   1      
 356   1              ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, SFP_PAGE_04H);
 357   1              JUDGE_RETURN(ret);
 358   1      
 359   1              for(channel = 0; channel < CHANNEL_MAX; channel++)
 360   1              {
 361   2                      ret = i2c_master_read(I2C_DEVICE_ADDR, rssi_addr[channel], (uint8_t *)&rssi_ua[channel], 2);
 362   2              }
 363   1              uart_printf( "\r\nRssi_ua %-5hu %-5hu %-5hu %-5hu", rssi_ua[0],rssi_ua[1],rssi_ua[2],rssi_ua[3]);
 364   1      
 365   1              return ret;
 366   1      }
 367          
 368          uint32_t qsfp28_get_mod_soft_type()
 369          {
 370   1              uint32_t ret = RET_OK;
 371   1              static uint16_t num = 0;
 372   1      
 373   1              _mod_type         = INVALID;
 374   1              _mod_sub_type = INVALID;
 375   1              _mod_hw_rev   = INVALID;
 376   1      
 377   1              ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, SFP_PAGE_05H);
 378   1              JUDGE_RETURN(ret);
 379   1      
 380   1              i2c_master_read_byte(I2C_DEVICE_ADDR, MSA_OFF_MODULE_TYPE, &_mod_type);
 381   1              i2c_master_read_byte(I2C_DEVICE_ADDR, MSA_OFF_MODULE_SUB_TYPE, &_mod_sub_type);
 382   1              i2c_master_read_byte(I2C_DEVICE_ADDR, MSA_OFF_HW_VER, &_mod_hw_rev);
 383   1      
 384   1              ret =  (uint32_t)_mod_type << 16 | (uint32_t)_mod_sub_type << 8 | _mod_hw_rev;
 385   1      
 386   1              /*
 387   1              switch(((uint32_t)_mod_type << 8)|((uint32_t)_mod_sub_type))
 388   1              {
 389   1                      case 0x101:
 390   1                              AOC_101_cmd_init();
 391   1                              break;
 392   1                      case 0x206:
 393   1                              CWDM4_206_cmd_init();
 394   1                              break;
 395   1                      case 0x301:
 396   1                              LR4_301_cmd_init();
 397   1                              break;
 398   1                      case 0x207:
 399   1                              CWDM4_207_cmd_init();
 400   1                              break;
 401   1                      case 0x211:
 402   1                              CWDM4_211_cmd_init();
 403   1                              break;
 404   1                      default:
 405   1                              break;
 406   1              }
 407   1              */
 408   1              terminal_register_cmd(NULL,NULL);
 409   1              return ret;
 410   1      }
*** WARNING C280 IN LINE 371 OF D:\Work Project\SingleChipWorkSpaveNew\C51_UBOOT\src\Efm8lb12_qsfp28.c: 'num': unreferen
             -ced local variable
 411          
 412          uint8_t qsfp28_get_mod_type()
 413          {
 414   1              return _mod_type;
C51 COMPILER V9.53.0.0   EFM8LB12_QSFP28                                                   10/14/2019 10:20:30 PAGE 8   

 415   1      }
 416          
 417          uint8_t qsfp28_get_mod_release_info()
 418          {
 419   1              uint8_t ret = RET_OK;
 420   1              char mod_name[32] = {0};
 421   1              MODULE_REALEASE_INFO  mod_realea_info;
 422   1      
 423   1              qsfp28_get_mod_soft_type();
 424   1              qsfp28_get_mod_name(mod_name);
 425   1      
 426   1              ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, SFP_PAGE_04H);
 427   1              JUDGE_RETURN(ret);
 428   1      
 429   1              ret = i2c_master_read(I2C_DEVICE_ADDR, SFP_MOD_REA_SEC, (uint8_t *)&mod_realea_info, sizeof(mod_realea_in
             -fo));
 430   1      
 431   1              if(strcmp(mod_name, "UNKNOWN"))
 432   1              {
 433   2                      uart_printf("\r\n%s-AM%bu_v%bu.%bu      20%bu.%bu.%bu-%bu:%bu",
 434   2                      mod_name, _mod_hw_rev,
 435   2                      mod_realea_info.ver_num_msb, mod_realea_info.ver_num_lsb,
 436   2                      mod_realea_info.year, mod_realea_info.mon, mod_realea_info.day,
 437   2                      mod_realea_info.hour, mod_realea_info.min);
 438   2              }
 439   1              else
 440   1              {
 441   2                      ret = RET_FAILED;
 442   2              }
 443   1              return ret;
 444   1      }
 445          
 446          uint8_t qsfp28_get_msa_lower_page_monitor()
 447          {
 448   1              return i2c_master_read(I2C_DEVICE_ADDR, MSA_PAGE_LOWER_MON_BASE_ADDR, (uint8_t *)&_lower_mon, sizeof(MSA_
             -PAGE_LOWER_MON_T));
 449   1      }
 450          
 451          static uint8_t qsfp28_get_ddmi_vcc(DDMI_CALI_TYPE type)
 452          {
 453   1              uint8_t ret = RET_OK;
 454   1      
 455   1              if(type == DDMI_CALI_BEFORE)
 456   1              {
 457   2                      uint16_t vcc;
 458   2      
 459   2                      ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, SFP_PAGE_04H);
 460   2                      JUDGE_RETURN(ret);
 461   2                      ret = i2c_master_read(I2C_DEVICE_ADDR, SFP_DDMI_VCC_MSB, (uint8_t *)&vcc, 2);           //uint:0.1mv
 462   2                      JUDGE_RETURN(ret);
 463   2                      uart_printf("\r\nDdmi_vcc:%f(v)",(float)vcc * 0.1 / 1000.0);
 464   2              }
 465   1              else if(type == DDMI_CALI_AFTER)
 466   1              {
 467   2                      //_lower_mon.vcc uint:0.1mV
 468   2                      uart_printf("\r\nDdmi_cali_vcc:%f(v)",(float)_lower_mon.vcc * 0.1 / 1000.0);  //uint:V
 469   2              }
 470   1      
 471   1              return ret;
 472   1      }
 473          
 474          static uint8_t qsfp28_get_ddmi_temp(DDMI_CALI_TYPE type)
 475          {
C51 COMPILER V9.53.0.0   EFM8LB12_QSFP28                                                   10/14/2019 10:20:30 PAGE 9   

 476   1              uint8_t ret = RET_OK;
 477   1      
 478   1              if(type == DDMI_CALI_BEFORE)
 479   1              {
 480   2                      int16_t temp = 0;
 481   2      
 482   2                      ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, SFP_PAGE_04H);
 483   2                      JUDGE_RETURN(ret);
 484   2                      ret = i2c_master_read(I2C_DEVICE_ADDR, SFP_DDMI_TEMP_MSB, (uint8_t *)&temp, 2);
 485   2                      JUDGE_RETURN(ret);
 486   2                      uart_printf("\r\nDdmi_temp:%f(C)", (float)temp/(float)DDMI_CALI_TEMP_SCALE);
 487   2              }
 488   1              else if(type == DDMI_CALI_AFTER)
 489   1              {
 490   2                      //_lower_mon.temp uint:1/256 C
 491   2                      uart_printf("\r\nDdmi_cali_temp:%f(C)",(float)_lower_mon.temp/(float)DDMI_CALI_TEMP_SCALE);  //uint:ÉãÊÏ
             -¶È
 492   2              }
 493   1      
 494   1              return ret;
 495   1      }
 496          
 497          static uint8_t qsfp28_get_ddmi_bias(uint8_t channel, DDMI_CALI_TYPE type)
 498          {
 499   1              uint8_t ret = RET_OK;
 500   1      
 501   1              if(channel >= CHANNEL_MAX)
 502   1              {
 503   2                      uart_printf("\r\nchannedl%bu is not support\r\n",channel);
 504   2                      ret = RET_FAILED;
 505   2              }
 506   1      
 507   1              if(type == DDMI_CALI_BEFORE)
 508   1              {
 509   2                      uint16_t bias;
 510   2                      uint8_t bias_addr[] = {0x84, 0x90, 0x9C, 0xA8};
 511   2      
 512   2                      ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, SFP_PAGE_04H);
 513   2                      JUDGE_RETURN(ret);
 514   2                      ret = i2c_master_read(I2C_DEVICE_ADDR, bias_addr[channel], (uint8_t *)&bias, 2);  //uint:0.1mA
 515   2                      JUDGE_RETURN(ret);
 516   2                      uart_printf("\r\nDdmi_bias%bu:%f(mA)",channel, (float)bias * 0.1);  //uint:mA
 517   2              }
 518   1              else if(type == DDMI_CALI_AFTER)
 519   1              {
 520   2                      //_lower_mon.txbias[channel]  uint:2uA
 521   2                      uart_printf("\r\nDdmi_cali_bias%bu:%f(mA)",channel, (float)_lower_mon.txbias[channel] * 2.0 / 1000.0);  
             -//uint:mA
 522   2              }
 523   1              return ret;
 524   1      }
 525          
 526          static uint8_t qsfp28_get_ddmi_txmon(uint8_t channel, DDMI_CALI_TYPE type)
 527          {
 528   1              uint8_t ret = RET_OK;
 529   1      
 530   1              if(channel >= CHANNEL_MAX)
 531   1              {
 532   2                      uart_printf("\r\nchannedl%bu is not support\r\n",channel);
 533   2                      ret = RET_FAILED;
 534   2              }
 535   1      
 536   1              if(type == DDMI_CALI_BEFORE)
C51 COMPILER V9.53.0.0   EFM8LB12_QSFP28                                                   10/14/2019 10:20:30 PAGE 10  

 537   1              {
 538   2                      uint16_t txmon;
 539   2                      uint8_t  txmon_addr[] = {0x88, 0x94, 0xA0, 0xAC};
 540   2      
 541   2                      ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, SFP_PAGE_04H);
 542   2                      JUDGE_RETURN(ret);
 543   2                      ret = i2c_master_read(I2C_DEVICE_ADDR, txmon_addr[channel], (uint8_t *)&txmon, 2);  //uint:0.1mA
 544   2                      if(qsfp28_get_mod_type() != MODULE_TYPE_SR4 )
 545   2                      {
 546   3                              uart_printf("\r\nDdmi_txmon%bu:%f(mV)",channel, (float)txmon * 0.1 );  //uint:mA
 547   3                      }
 548   2                      else 
 549   2                      {
 550   3                              uart_printf("\r\nDdmi_txmon%bu:%f(mA)",channel, (float)txmon * 0.1 );  //uint:mA
 551   3                      }
 552   2              }
 553   1              else if(type == DDMI_CALI_AFTER)
 554   1              {
 555   2                      //_lower_mon.txpower uint:0.1uW
 556   2                      uart_printf("\r\nDdmi_cali_txpower%bu:%f(dbm)",channel, 10.0 *log10(((float)_lower_mon.txpower[channel] 
             -* 0.1 /1000.0)));
 557   2              }
 558   1              return ret;
 559   1      }
 560          
 561          static uint8_t qsfp28_get_ddmi_rssi(uint8_t channel,DDMI_CALI_TYPE type )
 562          {
 563   1              uint8_t ret = RET_OK;
 564   1      
 565   1              if(channel >= CHANNEL_MAX)
 566   1              {
 567   2                      uart_printf("\r\nchannedl%d is not support\r\n",channel);
 568   2                      ret = RET_FAILED;
 569   2              }
 570   1      
 571   1              if(type == DDMI_CALI_BEFORE)
 572   1              {
 573   2                      uint16_t rssi;
 574   2                      uint8_t rssi_addr[] = {0x86, 0x92, 0x9E, 0xAA};
 575   2      
 576   2                      ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, SFP_PAGE_04H);
 577   2                      JUDGE_RETURN(ret);
 578   2                      ret = i2c_master_read(I2C_DEVICE_ADDR, rssi_addr[channel], (uint8_t *)&rssi, 2);  //uint:uA
 579   2                      JUDGE_RETURN(ret);
 580   2                      uart_printf("\r\nDdmi_rssi%bu:%hu(uA)",channel, rssi);
 581   2              }
 582   1              else if(type == DDMI_CALI_AFTER)
 583   1              {
 584   2                      uart_printf("\r\nDdmi_cali_rxpower%bu:%f(dbm)",channel, 10 *log10(((float)_lower_mon.rssi[channel] * 0.1
             - /1000.0)));
 585   2              }
 586   1              return ret;
 587   1      }
 588          
 589          uint8_t qsfp28_get_ddmi(DDMI_DATA_TYPE ddmi_type, uint8_t channel, DDMI_CALI_TYPE type)
 590          {
 591   1              uint8_t ret = RET_OK;
 592   1      
 593   1              switch(ddmi_type)
 594   1              {
 595   2                      case DDMI_VCC:
 596   2                      {
 597   3                              ret = qsfp28_get_ddmi_vcc(type);
C51 COMPILER V9.53.0.0   EFM8LB12_QSFP28                                                   10/14/2019 10:20:30 PAGE 11  

 598   3                              break;
 599   3                      }
 600   2                      case DDMI_TEMP:
 601   2                      {
 602   3                              ret = qsfp28_get_ddmi_temp(type);
 603   3                              break;
 604   3                      }
 605   2                      case DDMI_BIAS:
 606   2                      {
 607   3                              ret = qsfp28_get_ddmi_bias(channel, type);
 608   3                              break;
 609   3                      }
 610   2                      case DDMI_TXMON:
 611   2                      {
 612   3                              ret = qsfp28_get_ddmi_txmon(channel, type);
 613   3                              break;
 614   3                      }
 615   2                      case DDMI_RSSI:
 616   2                      {
 617   3                              ret = qsfp28_get_ddmi_rssi(channel, type);
 618   3                              break;
 619   3                      }
 620   2                      default:
 621   2                              break;
 622   2              }
 623   1              return ret;
 624   1      }
 625          
 626          uint8_t qsfp28_set_ddmi_cali_para(DDMI_DATA_TYPE ddmi_type, uint8_t channel, DDMI_CALI_PARA_T* cali_para)
 627          {
 628   1              uint8_t ret = RET_OK;
 629   1              uint8_t page_select[] = {SFP_PAGE_06H, SFP_PAGE_07H, SFP_PAGE_07H, SFP_PAGE_07H};
 630   1      
 631   1              switch(ddmi_type)
 632   1              {
 633   2                      case DDMI_VCC:
 634   2                      {
 635   3                              ret = smb_write_page_byte(I2C_DEVICE_ADDR, (uint8_t)SFP_PAGE_06H, PAGE6_DDMI_CALI_VCC_OFFSET_MSB, (uint
             -8_t *)&cali_para->vcc, 2);
 636   3                              break;
 637   3                      }
 638   2                      case DDMI_TEMP:
 639   2                      {
 640   3                              ret = smb_write_page_byte(I2C_DEVICE_ADDR, (uint8_t)SFP_PAGE_06H, PAGE6_DDMI_CALI_TEMP_OFFSET_MSB, (uin
             -t8_t *)&cali_para->temp, 2);
 641   3                              break;
 642   3                      }
 643   2                      case DDMI_BIAS:
 644   2                      {
 645   3                              uint8_t bias_para_addr[] = {PAGE6_DDMI_CALI_CH0_BIAS_BASE_ADDR, PAGE7_DDMI_CALI_CH1_BIAS_BASE_ADDR, PAG
             -E7_DDMI_CALI_CH2_BIAS_BASE_ADDR, PAGE7_DDMI_CALI_CH3_BIAS_BASE_ADDR};
 646   3                              ret = smb_write_page_byte(I2C_DEVICE_ADDR, (uint8_t)page_select[channel], bias_para_addr[channel], (uin
             -t8_t *)&cali_para->current[channel].bias, sizeof(cali_para->current[0].bias));
 647   3                              break;
 648   3                      }
 649   2                      case DDMI_TXMON:
 650   2                      {
 651   3                              uint8_t txpower_para_addr[] = {PAGE6_DDMI_CALI_CH0_TXPOWER_BASE_ADDR, PAGE7_DDMI_CALI_CH1_TXPOWER_BASE_
             -ADDR, PAGE7_DDMI_CALI_CH2_TXPOWER_BASE_ADDR, PAGE7_DDMI_CALI_CH3_TXPOWER_BASE_ADDR};
 652   3                              ret = smb_write_page_byte(I2C_DEVICE_ADDR, page_select[channel], txpower_para_addr[channel], (uint8_t *
             -)&cali_para->current[channel].txpower, sizeof(cali_para->current[0].txpower));
 653   3                              break;
 654   3                      }
C51 COMPILER V9.53.0.0   EFM8LB12_QSFP28                                                   10/14/2019 10:20:30 PAGE 12  

 655   2                      case DDMI_RSSI:
 656   2                      {
 657   3                              uint8_t rxpower_para_addr[] = {PAGE6_DDMI_CALI_CH0_RXPOWER_BASE_ADDR, PAGE7_DDMI_CALI_CH1_RXPOWER_BASE_
             -ADDR, PAGE7_DDMI_CALI_CH2_RXPOWER_BASE_ADDR, PAGE7_DDMI_CALI_CH3_RXPOWER_BASE_ADDR};
 658   3                              ret = smb_write_page_byte(I2C_DEVICE_ADDR, page_select[channel], rxpower_para_addr[channel], (uint8_t *
             -)&cali_para->current[channel].rxpower, sizeof(cali_para->current[0].rxpower));
 659   3                              break;
 660   3                      }
 661   2                      default:
 662   2                              break;
 663   2              }
 664   1              return ret;
 665   1      }
 666          
 667          uint8_t qsfp28_get_ddmi_cali_para(DDMI_DATA_TYPE ddmi_type, uint8_t channel, DDMI_CALI_PARA_T* cali_para)
 668          {
 669   1              uint8_t ret = RET_OK;
 670   1      
 671   1              if(channel == 0x0 || ddmi_type == DDMI_VCC || ddmi_type == DDMI_TEMP)
 672   1              {
 673   2                      ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, SFP_PAGE_06H);
 674   2                      JUDGE_RETURN(ret);
 675   2              }
 676   1              else
 677   1              {
 678   2                      ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, SFP_PAGE_07H);
 679   2                      JUDGE_RETURN(ret);
 680   2              }
 681   1      
 682   1              switch(ddmi_type)
 683   1              {
 684   2                      case DDMI_VCC:
 685   2                      {
 686   3                              ret = i2c_master_read(I2C_DEVICE_ADDR, PAGE6_DDMI_CALI_VCC_OFFSET_MSB, (uint8_t *)&cali_para->vcc, 2);
 687   3                              break;
 688   3                      }
 689   2                      case DDMI_TEMP:
 690   2                      {
 691   3                              ret = i2c_master_read(I2C_DEVICE_ADDR, PAGE6_DDMI_CALI_TEMP_OFFSET_MSB, (uint8_t *)&cali_para->temp, 2)
             -;
 692   3                              break;
 693   3                      }
 694   2                      case DDMI_BIAS:
 695   2                      {
 696   3                              uint8_t bias_para_addr[] = {PAGE6_DDMI_CALI_CH0_BIAS_BASE_ADDR, PAGE7_DDMI_CALI_CH1_BIAS_BASE_ADDR, PAG
             -E7_DDMI_CALI_CH2_BIAS_BASE_ADDR, PAGE7_DDMI_CALI_CH3_BIAS_BASE_ADDR};
 697   3                              ret = i2c_master_read(I2C_DEVICE_ADDR, bias_para_addr[channel], (uint8_t *)&cali_para->current[channel]
             -.bias, sizeof(cali_para->current[0].bias));
 698   3                              break;
 699   3                      }
 700   2                      case DDMI_TXMON:
 701   2                      {
 702   3                              uint8_t txpower_para_addr[] = {PAGE6_DDMI_CALI_CH0_TXPOWER_BASE_ADDR, PAGE7_DDMI_CALI_CH1_TXPOWER_BASE_
             -ADDR,PAGE7_DDMI_CALI_CH2_TXPOWER_BASE_ADDR, PAGE7_DDMI_CALI_CH3_TXPOWER_BASE_ADDR};
 703   3                              ret = i2c_master_read(I2C_DEVICE_ADDR, txpower_para_addr[channel], (uint8_t *)&cali_para->current[chann
             -el].txpower, sizeof(cali_para->current[0].txpower));
 704   3                              break;
 705   3                      }
 706   2                      case DDMI_RSSI:
 707   2                      {
 708   3                              uint8_t rxpower_para_addr[] = {PAGE6_DDMI_CALI_CH0_RXPOWER_BASE_ADDR, PAGE7_DDMI_CALI_CH1_RXPOWER_BASE_
             -ADDR, PAGE7_DDMI_CALI_CH2_RXPOWER_BASE_ADDR, PAGE7_DDMI_CALI_CH3_RXPOWER_BASE_ADDR};
 709   3                              ret = i2c_master_read(I2C_DEVICE_ADDR, rxpower_para_addr[channel], (uint8_t *)&cali_para->current[chann
C51 COMPILER V9.53.0.0   EFM8LB12_QSFP28                                                   10/14/2019 10:20:30 PAGE 13  

             -el].rxpower, sizeof(cali_para->current[0].rxpower));
 710   3                              break;
 711   3                      }
 712   2                      default:
 713   2                              break;
 714   2              }
 715   1      
 716   1              return ret;
 717   1      }
 718          
 719          uint8_t qsfp28_set_lut_tab(uint8_t channel, MSA_LUT_TYPE type,  MSA_LASER_CH_CFG_T cfg)
 720          {
 721   1              uint8_t ret = RET_OK;
 722   1      
 723   1              ret = smb_write_page_byte(I2C_DEVICE_ADDR, lut_page_select[type], lut_temp_select[type], (uint8_t *)&cfg.
             -temp, 2);
 724   1              JUDGE_RETURN(ret);
 725   1              ret = smb_write_page_byte(I2C_DEVICE_ADDR, lut_page_select[type], lut_laser_cfg_select[type][channel], (u
             -int8_t *)&cfg.bias, 6);
 726   1              return ret;
 727   1      }
 728          
 729          uint8_t qsfp28_get_lut_tab(uint8_t channel,LUT_SHOW_TYPE show_type, MSA_LUT_TYPE type)
 730          {
 731   1              uint8_t *lt = "lt";
 732   1              uint8_t *mt = "mt";
 733   1              uint8_t *ht = "ht";
 734   1              uint8_t ret = RET_OK;
 735   1              MSA_LASER_CH_CFG_T laser_cfg;
 736   1              uint8_t *temp_type[MSA_LUT_TYPE_MAX] = {"lt","mt","ht"};
 737   1      
 738   1              ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, lut_page_select[type]);
 739   1              JUDGE_RETURN(ret);
 740   1      
 741   1              ret = i2c_master_read(I2C_DEVICE_ADDR, lut_temp_select[type], (uint8_t *)&laser_cfg.temp, 2);
 742   1              ret = i2c_master_read(I2C_DEVICE_ADDR, lut_laser_cfg_select[type][channel], (uint8_t *)&laser_cfg.bias, 6
             -);
 743   1      
 744   1              if(show_type == PART_LUT_INFO)
 745   1              {
 746   2                      uart_printf("\r\nch%bu-%s:temp     bias    mod     crossing", channel,temp_type[type]);
 747   2                      uart_printf("\r\n\t%hd\t%hu\t%hu\t%hd",laser_cfg.temp/DDMI_CALI_TEMP_SCALE, laser_cfg.bias, laser_cfg.mo
             -d, laser_cfg.cross);
 748   2              }
 749   1              else
 750   1              {
 751   2                      uart_printf("\r\nch%bu-%s\t%hd\t%hu\t%hu\t%hd",channel,temp_type[type],laser_cfg.temp/DDMI_CALI_TEMP_SCA
             -LE, laser_cfg.bias, laser_cfg.mod, laser_cfg.cross);
 752   2              }
 753   1      
 754   1              return ret;
 755   1      }
 756          
 757          
 758          uint8_t qsfp28_set_lut_tab_para_from_reg_inner(uint8_t channel, SAVE_CUR_LUT_TAB cur_lut)
 759          {
 760   1              uint8_t ret = RET_OK;
 761   1      
 762   1              ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, SFP_PAGE_04H);
 763   1              JUDGE_RETURN(ret);
 764   1      
 765   1              ret = i2c_master_write_byte(I2C_DEVICE_ADDR, SFP_DBG_READ_DATA0, cur_lut);
 766   1              ret = i2c_master_write_byte(I2C_DEVICE_ADDR, SFP_DBG_READ_DATA1, channel);
C51 COMPILER V9.53.0.0   EFM8LB12_QSFP28                                                   10/14/2019 10:20:30 PAGE 14  

 767   1              ret = i2c_master_write_byte(I2C_DEVICE_ADDR, SFP_DBG_CMD, DBG_SET_CUR_LUT_CMD);
 768   1      
 769   1              if(qsfp28_get_cmd_status() == false)
 770   1              {
 771   2                      uart_printf("%s","\r\nSet lut tab now is failed");
 772   2                      ret = RET_FAILED;
 773   2              }
 774   1              return ret;
 775   1      }
 776          
 777          uint8_t qsfp28_get_fixed_temp_point_apc_value(int8_t temp, uint8_t channel)
 778          {
 779   1              MSA_LASER_CH_CFG_T cfg;
 780   1              uint8_t ret = RET_OK;
 781   1      
 782   1              cfg.temp = temp * DDMI_CALI_TEMP_SCALE; //because the module receive result is actual temp * 256
 783   1      
 784   1              if(channel == CHANNEL_MAX)
 785   1              {
 786   2                      return RET_FAILED;
 787   2              }
 788   1      
 789   1              uart_printf("\r\n   ch%bu:temp     bias    mod     crossing", channel);
 790   1      
 791   1              ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, SFP_PAGE_04H);
 792   1              JUDGE_RETURN(ret);
 793   1              ret = i2c_master_write_byte(I2C_DEVICE_ADDR, SFP_DBG_READ_DATA0, channel & 0xFF);
 794   1              ret = i2c_master_write(I2C_DEVICE_ADDR, SFP_DBG_READ_DATA2, (uint8_t *)&cfg.temp, 2);
 795   1              ret = i2c_master_write_byte(I2C_DEVICE_ADDR, SFP_DBG_CMD, DBG_APC_CALI_CMD);
 796   1      
 797   1              if(qsfp28_get_cmd_status() == false)
 798   1              {
 799   2                      uart_printf("%s","\r\nQsfp28_get_fixed_temp_point_apc_value failed");
 800   2                      return RET_FAILED;
 801   2              }
 802   1      
 803   1              ret = i2c_master_read(I2C_DEVICE_ADDR, SFP_DBG_READ_DATA4, (uint8_t *)&cfg.bias, 2);
 804   1              ret = i2c_master_read(I2C_DEVICE_ADDR, SFP_DBG_READ_DATA6, (uint8_t *)&cfg.mod, 2);
 805   1              ret = i2c_master_read(I2C_DEVICE_ADDR, SFP_DBG_READ_DATA8, (uint8_t *)&cfg.cross, 2);
 806   1              uart_printf("\r\n\t%hd\t%hu\t%hu\t%hd",cfg.temp/DDMI_CALI_TEMP_SCALE, cfg.bias, cfg.mod, cfg.cross);
 807   1      
 808   1              return ret;
 809   1      }
 810          
 811          
 812          uint8_t  qsfp28_get_cur_apc_value(uint8_t channel)
 813          {
 814   1              uint8_t ret = RET_OK;
 815   1              MSA_LASER_CH_CFG_T cfg;
 816   1      
 817   1              if(channel == CHANNEL_MAX)
 818   1              {
 819   2                      return RET_FAILED;
 820   2              }
 821   1      
 822   1              ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, SFP_PAGE_04H);
 823   1              JUDGE_RETURN(ret);
 824   1      
 825   1              ret = i2c_master_read(I2C_DEVICE_ADDR, SFP_DDMI_TEMP_MSB, (uint8_t *)&cfg.temp, 2);
 826   1              ret = ((RET_FAILED == qsfp28_get_fixed_temp_point_apc_value(cfg.temp/DDMI_CALI_TEMP_SCALE, channel))? RET
             -_FAILED : RET_OK);
 827   1      
 828   1              return ret;
C51 COMPILER V9.53.0.0   EFM8LB12_QSFP28                                                   10/14/2019 10:20:30 PAGE 15  

 829   1      }
 830          
 831          static uint8_t qsfp28_read_log()
 832          {
 833   1              uint8_t log[128];
 834   1              uint8_t i = 0, len = 0, ret = RET_OK;
 835   1      
 836   1              memset(log, '\0', sizeof(log));
 837   1      
 838   1              ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, MSA_PAGE_02H);
 839   1              JUDGE_RETURN(ret);
 840   1      
 841   1              ret = i2c_master_read(I2C_DEVICE_ADDR, SFP_DEBUG_LOG_START_ADDR, &log[0], 128);
 842   1              uart_printf("\r\nLog:%s",log);
 843   1      
 844   1              return ret;
 845   1      }
 846          
 847          
 848          uint8_t qsfp28_debug_log_handle(DEBUG_LOG_ACTION action)
 849          {
 850   1              uint8_t ret = RET_OK;
 851   1      
 852   1              if(action == READ_LOG_CMD)
 853   1              {
 854   2                      ret = qsfp28_read_log();
 855   2              }
 856   1              else if(action == DISABLE_LOG_CMD || action == ENABLE_LOG_CMD || action == CLEAR_LOG_CMD)
 857   1              {
 858   2                      ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, SFP_PAGE_04H);
 859   2                      JUDGE_RETURN(ret);
 860   2                      ret = i2c_master_write_byte(I2C_DEVICE_ADDR, SFP_DBG_READ_DATA0, action);
 861   2                      ret = i2c_master_write_byte(I2C_DEVICE_ADDR, SFP_DBG_CMD, DBG_DEBUG_LOG_CMD);
 862   2      
 863   2                      if(qsfp28_get_cmd_status() == false)
 864   2                      {
 865   3                              uart_printf("%s","\r\nQsfp28_debug_log_handle failed");
 866   3                              ret = RET_FAILED;
 867   3                      }
 868   2              }
 869   1              else
 870   1              {
 871   2                      ret = RET_FAILED;
 872   2              }
 873   1              return ret;
 874   1      }
 875          
 876          
 877          static uint8_t qsfp28_eep_save(uint8_t dev_addr, uint16_t offset_addr, uint8_t value)
 878          {
 879   1              uint8_t ret = RET_OK;
 880   1              SAVE_REG_T save_reg;
 881   1      
 882   1              save_reg.devAddr        = dev_addr;
 883   1              save_reg.offsetAddr = offset_addr;
 884   1              save_reg.value          = value;
 885   1      
 886   1              ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, SFP_PAGE_04H);
 887   1              JUDGE_RETURN(ret);
 888   1      
 889   1              ret = i2c_master_write(I2C_DEVICE_ADDR, SFP_DBG_READ_DATA0, (uint8_t *)&save_reg, sizeof(SAVE_REG_T));
 890   1              ret = i2c_master_write_byte(I2C_DEVICE_ADDR, SFP_DBG_CMD, DBG_SAVE_REG_TO_EEP_CMD);
 891   1      
C51 COMPILER V9.53.0.0   EFM8LB12_QSFP28                                                   10/14/2019 10:20:30 PAGE 16  

 892   1              if(qsfp28_get_cmd_status() == false)
 893   1              {
 894   2                      uart_printf("%s","\r\neep save failed");
 895   2                      ret = RET_FAILED;
 896   2              }
 897   1      
 898   1              return ret;
 899   1      }
 900          
 901          
 902          static uint8_t qsfp28_eep_show()
 903          {
 904   1              uint8_t eep_data_size = 0, i = 0, ret = RET_OK;
 905   1              SAVE_REG_T save_reg;
 906   1      
 907   1              ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, SFP_PAGE_05H);
 908   1              JUDGE_RETURN(ret);
 909   1      
 910   1              ret = i2c_master_read_byte(I2C_DEVICE_ADDR, EEP_DATA_SIZE, &eep_data_size);
 911   1      
 912   1              ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, SFP_PAGE_0AH);
 913   1              JUDGE_RETURN(ret);
 914   1      
 915   1              uart_printf("\r\n\tDevAddr\t\tOffsetAddr\tValue");
 916   1              for (i = 0; i < (eep_data_size/4); i++)
 917   1              {
 918   2                      ret = i2c_master_read(I2C_DEVICE_ADDR, PAGE10_START_ADDR + 4 * i, (uint8_t *)&save_reg, sizeof(SAVE_REG_
             -T));
 919   2                      uart_printf("\r\n\t0x%bx\t\t0x%hx\t\t0x%bx",save_reg.devAddr, save_reg.offsetAddr, save_reg.value);
 920   2                      com_delay(10);
 921   2              }
 922   1      
 923   1              return ret;
 924   1      }
 925          
 926          uint8_t qsfp28_eep_handle(EEP_ACTION action, uint8_t dev_addr, uint16_t offset_addr, uint8_t value)
 927          {
 928   1              uint8_t ret = RET_OK;
 929   1      
 930   1              switch(action)
 931   1              {
 932   2                      case EEP_INIT:
 933   2                      {
 934   3                              ret = qsfp28_msa_page4_dbg_cmd(DBG_EEP_INIT_CMD);
 935   3                              break;
 936   3                      }
 937   2                      case EEP_SAVE:
 938   2                      {
 939   3                              ret = qsfp28_eep_save(dev_addr, offset_addr, value);
 940   3                              break;
 941   3                      }
 942   2                      case EEP_SHOW:
 943   2                      {
 944   3                              ret = qsfp28_eep_show();
 945   3                              break;
 946   3                      }
 947   2                      case EEP_ERASE:
 948   2                      {
 949   3                              ret = qsfp28_msa_page4_dbg_cmd(DBG_EEP_ERASE_CMD);  //erase all eep info
 950   3                              break;
 951   3                      }
 952   2                      default:
 953   2                              break;
C51 COMPILER V9.53.0.0   EFM8LB12_QSFP28                                                   10/14/2019 10:20:30 PAGE 17  

 954   2              }
 955   1      
 956   1              return ret;
 957   1      }
 958          
 959          uint8_t qsfp28_msa_page4_dbg_cmd(MSA_PAGE4_DBG_CMD_T cmd)
 960          {
 961   1              uint8_t ret = RET_OK;
 962   1      
 963   1              ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, SFP_PAGE_04H);
 964   1              JUDGE_RETURN(ret);
 965   1      
 966   1              ret = i2c_master_write_byte(I2C_DEVICE_ADDR, SFP_DBG_CMD, cmd);
 967   1      
 968   1              if(qsfp28_get_cmd_status() == false)
 969   1              {
 970   2                      uart_printf("%s","\r\nCmd failed");
 971   2                      ret = RET_FAILED;
 972   2              }
 973   1      
 974   1              return ret;
 975   1      }
 976          
 977          
 978          uint8_t qsfp28_config_mod_console(bool enable)
 979          {
 980   1              uint8_t SFRPAGE_SAVE = SFRPAGE, ret = RET_OK;
 981   1              uint8_t tmp = enable ? 1 : 0;
 982   1      
 983   1              ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, SFP_PAGE_04H);
 984   1              JUDGE_RETURN(ret);
 985   1      
 986   1              ret = i2c_master_write_byte(I2C_DEVICE_ADDR, SFP_DBG_READ_DATA0, tmp);
 987   1              ret = i2c_master_write_byte(I2C_DEVICE_ADDR, SFP_DBG_CMD, DBG_SET_MOD_CONSOLE);
 988   1      
 989   1              if(enable)  //enable module uart func
 990   1              {
 991   2                      if(qsfp28_get_cmd_status() == false)
 992   2                      {
 993   3                              uart_printf("%s","\r\nenable module uart failed");
 994   3                              return RET_FAILED;
 995   3                      }
 996   2      
 997   2                      SFRPAGE = 0x0;
 998   2                      P1MDOUT &= ~P1MDOUT_B5__PUSH_PULL ;
 999   2      
1000   2                      SFRPAGE = 0x20;
1001   2                      P2MDOUT &= ~P2MDOUT_B0__PUSH_PULL ;
1002   2      
1003   2                      RESET  = 1;
1004   2                      MODSEL = 1;
1005   2      
1006   2                      SFRPAGE = SFRPAGE_SAVE;
1007   2              }
1008   1              else  //disable module uart func
1009   1              {
1010   2                      SFRPAGE = 0x0;
1011   2                      P1MDOUT |= P1MDOUT_B5__PUSH_PULL ;
1012   2      
1013   2                      SFRPAGE = 0x20;
1014   2                      P2MDOUT |= P2MDOUT_B0__PUSH_PULL ;
1015   2      
1016   2                      RESET  = 1;
C51 COMPILER V9.53.0.0   EFM8LB12_QSFP28                                                   10/14/2019 10:20:30 PAGE 18  

1017   2                      MODSEL = 0;
1018   2      
1019   2                      if(qsfp28_get_cmd_status() == false)
1020   2                      {
1021   3                              uart_printf("%s","\r\ndisable module uart failed");
1022   3                              return RET_FAILED;
1023   3                      }
1024   2              }
1025   1      
1026   1              SFRPAGE = SFRPAGE_SAVE;
1027   1      
1028   1              return ret;
1029   1      }
1030          
1031          uint8_t qsfp28_get_tec(SFP_PAGE page,uint8_t tec,uint16_t *Pdata)
1032          {
1033   1              uint8_t datab[2];
1034   1              uint8_t ret = RET_OK;
1035   1      
1036   1              ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, page);
1037   1              JUDGE_RETURN(ret);
1038   1              ret = i2c_master_read(I2C_DEVICE_ADDR,tec,datab,2);
1039   1              *Pdata = (uint16_t)((datab[0] << 8) & 0xff00)| datab[1];
1040   1      
1041   1              return ret;
1042   1      }
1043          
1044          RETURN_VALUE_TYPE LR4_301_set_tec_able(uint8_t enale)
1045          {
1046   1              RETURN_VALUE_TYPE  ret = RET_OK;
1047   1      
1048   1              ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, SFP_PAGE_04H);
1049   1              JUDGE_RETURN(ret);
1050   1      
1051   1              ret = i2c_master_write_byte(I2C_DEVICE_ADDR, SFP_DBG_CMD, DBG_TEC_ENABLE_CMD);
1052   1              ret = i2c_master_write_byte(I2C_DEVICE_ADDR, SFP_DBG_READ_DATA0, enale);
1053   1      
1054   1              if(qsfp28_get_cmd_status() == false)
1055   1              {
1056   2                      uart_printf("%s","\r\nenable module uart failed");
1057   2              }
1058   1              return ret;
1059   1      }
1060          
1061          RETURN_VALUE_TYPE  qsfp28_set_tec(SFP_PAGE page,uint8_t tec,uint16_t *Pdata)
1062          {
1063   1              uint8_t ret = RET_OK;
1064   1              uint8_t datab[2] = {0};
1065   1      
1066   1              datab[0]= *Pdata >> 8;
1067   1              datab[1]= *Pdata;
1068   1      
1069   1              ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, page);
1070   1              JUDGE_RETURN(ret);
1071   1              ret = smb_write_page_byte(I2C_DEVICE_ADDR, page, tec, datab, 2);
1072   1              return ret;
1073   1      }
1074          
1075          static uint8_t qsfp28_get_each_thrhld_value(MSA_PAGE3_ALARM_WARING_THRESHOLD_T type)
1076          {
1077   1              uint16_t value16 = 0;
1078   1              uint8_t ret = RET_OK;
1079   1      
C51 COMPILER V9.53.0.0   EFM8LB12_QSFP28                                                   10/14/2019 10:20:30 PAGE 19  

1080   1              ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, MSA_PAGE_03H);
1081   1              JUDGE_RETURN(ret);
1082   1      
1083   1              ret = i2c_master_read(I2C_DEVICE_ADDR, page3_alarm_wran_select[type], (uint8_t *)&value16, 2);
1084   1      
1085   1              switch(type)
1086   1              {
1087   2                      case TEMP_HIGH_ALARM:
1088   2                      {
1089   3                              uart_printf("\r\nthrhld_temp_high_alarm\t:%f(C)", ((float)(int16_t)value16)/(float)DDMI_CALI_TEMP_SCALE
             -);
1090   3                              break;
1091   3                      }
1092   2                      case TEMP_LOW_ALARM:
1093   2                      {
1094   3                              uart_printf("\r\nthrhld_temp_low_alarm\t:%f(C)", ((float)(int16_t)value16)/(float)DDMI_CALI_TEMP_SCALE)
             -;
1095   3                              break;
1096   3                      }
1097   2                      case TEMP_HIGH_WARN:
1098   2                      {
1099   3                              uart_printf("\r\nthrhld_temp_high_warn\t:%f(C)", ((float)(int16_t)value16)/(float)DDMI_CALI_TEMP_SCALE)
             -;
1100   3                              break;
1101   3                      }
1102   2                      case TEMP_LOW_WARN:
1103   2                      {
1104   3                              uart_printf("\r\nthrhld_temp_low_warn\t:%f(C)", ((float)(int16_t)value16)/(float)DDMI_CALI_TEMP_SCALE);
1105   3                              break;
1106   3                      }
1107   2                      case VCC_HIGH_ALARM:    //vcc
1108   2                      {
1109   3                              uart_printf("\r\nthrhld_vcc_high_alarm\t:%f(V)", (float)(value16) * 0.1 / 1000.0);
1110   3                              break;
1111   3                      }
1112   2                      case VCC_LOW_ALARM:
1113   2                      {
1114   3                              uart_printf("\r\nthrhld_vcc_low_alarm\t:%f(V)", (float)(value16) * 0.1 / 1000.0);
1115   3                              break;
1116   3                      }
1117   2                      case VCC_HIGH_WARN:
1118   2                      {
1119   3                              uart_printf("\r\nthrhld_vcc_high_warn\t:%f(V)", (float)(value16) * 0.1 / 1000.0);
1120   3                              break;
1121   3                      }
1122   2                      case VCC_LOW_WARN:
1123   2                      {
1124   3                              uart_printf("\r\nthrhld_vcc_low_warn\t:%f(V)", (float)(value16) * 0.1 / 1000.0);
1125   3                              break;
1126   3                      }
1127   2                      case RXPWR_HIGH_ALARM: //rxpwr
1128   2                      {
1129   3                              uart_printf("\r\nthrhld_rxpwr_high_alarm\t:%f(dbm)", 10.0 *log10(((float)value16 * 0.1 /1000.0)));
1130   3                              break;
1131   3                      }
1132   2                      case RXPWR_LOW_ALARM:
1133   2                      {
1134   3                              uart_printf("\r\nthrhld_rxpwr_low_alarm\t:%f(dbm)", 10.0 *log10(((float)value16 * 0.1 /1000.0)));
1135   3                              break;
1136   3                      }
1137   2                      case RXPWR_HIGH_WARN:
1138   2                      {
1139   3                              uart_printf("\r\nthrhld_rxpwr_high_warn\t:%f(dbm)", 10.0 *log10(((float)value16 * 0.1 /1000.0)));
C51 COMPILER V9.53.0.0   EFM8LB12_QSFP28                                                   10/14/2019 10:20:30 PAGE 20  

1140   3                              break;
1141   3                      }
1142   2                      case RXPWR_LOW_WARN:
1143   2                      {
1144   3                              uart_printf("\r\nthrhld_rxpwr_low_warn\t:%f(dbm)", 10.0 *log10(((float)value16 * 0.1 /1000.0)));
1145   3                              break;
1146   3                      }
1147   2                      case TXBIAS_HIGH_ALARM: //txbias
1148   2                      {
1149   3                              uart_printf("\r\nthrhld_txbias_high_alarm:%f(mA)", (float)value16 * 2.0 / 1000.0);
1150   3                              break;
1151   3                      }
1152   2                      case TXBIAS_LOW_ALARM:
1153   2                      {
1154   3                              uart_printf("\r\nthrhld_txbias_low_alarm\t:%f(mA)", (float)value16 * 2.0 / 1000.0);
1155   3                              break;
1156   3                      }
1157   2                      case TXBIAS_HIGH_WARN:
1158   2                      {
1159   3                              uart_printf("\r\nthrhld_txbias_high_warn\t:%f(mA)", (float)value16 * 2.0 / 1000.0);
1160   3                              break;
1161   3                      }
1162   2                      case TXBIAS_LOW_WARN:
1163   2                      {
1164   3                              uart_printf("\r\nthrhld_txbias_low_warn\t:%f(mA)", (float)value16 * 2.0 / 1000.0);
1165   3                              break;
1166   3                      }
1167   2                      case TXPWR_HIGH_ALARM:  //txpwr
1168   2                      {
1169   3                              uart_printf("\r\nthrhld_txpwr_high_alarm\t:%f(dbm)", 10.0 *log10(((float)value16 * 0.1 /1000.0)));
1170   3                              break;
1171   3                      }
1172   2                      case TXPWR_LOW_ALARM:
1173   2                      {
1174   3                              uart_printf("\r\nthrhld_txpwr_low_alarm\t:%f(dbm)", 10.0 *log10(((float)value16 * 0.1 /1000.0)));
1175   3                              break;
1176   3                      }
1177   2                      case TXPWR_HIGH_WARN:
1178   2                      {
1179   3                              uart_printf("\r\nthrhld_txpwr_high_warn\t:%f(dbm)", 10.0 *log10(((float)value16 * 0.1 /1000.0)));
1180   3                              break;
1181   3                      }
1182   2                      case TXPWR_LOW_WARN:
1183   2                      {
1184   3                              uart_printf("\r\nthrhld_txpwr_low_warn\t:%f(dbm)", 10.0 *log10(((float)value16 * 0.1 /1000.0)));
1185   3                              break;
1186   3                      }
1187   2                      default:
1188   2                      {
1189   3                              ret = RET_FAILED;
1190   3                              break;
1191   3                      }
1192   2              }
1193   1      
1194   1              return ret;
1195   1      }
1196          
1197          uint8_t qsfp28_set_thrhld_value(MSA_PAGE3_ALARM_WARING_THRESHOLD_T type, uint16_t value)
1198          {
1199   1              uint8_t ret = RET_OK;
1200   1      
1201   1              ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, MSA_PAGE_03H);
1202   1              JUDGE_RETURN(ret);
C51 COMPILER V9.53.0.0   EFM8LB12_QSFP28                                                   10/14/2019 10:20:30 PAGE 21  

1203   1              ret = i2c_master_write(I2C_DEVICE_ADDR, page3_alarm_wran_select[type],(uint8_t *)&value, 2);
1204   1      
1205   1              return ret;
1206   1      }
1207          
1208          uint8_t qsfp28_get_thrhld_value(MSA_PAGE3_ALARM_WARING_THRESHOLD_T type)
1209          {
1210   1              uint16_t value = 0;
1211   1              uint8_t i = 0, ret = RET_OK;
1212   1      
1213   1              if(type >= TEMP_HIGH_ALARM && type < HTRHLD_ALL)
1214   1              {
1215   2                      ret = qsfp28_get_each_thrhld_value(type);
1216   2              }
1217   1              else if(type == HTRHLD_ALL)
1218   1              {
1219   2                      for(i = TEMP_HIGH_ALARM; i < HTRHLD_ALL; i++)
1220   2                      {
1221   3                              ret = qsfp28_get_each_thrhld_value(i);
1222   3                      }
1223   2              }
1224   1              else
1225   1              {
1226   2                      ret = RET_FAILED;
1227   2              }
1228   1      
1229   1              return ret;
1230   1      }
1231          
1232          uint8_t qsfp28_get_module_class()
1233          {
1234   1              uint8_t ret = RET_FAILED;
1235   1              uint8_t value = 0;
1236   1      
1237   1              ret = smb_read_page_byte(I2C_DEVICE_ADDR,SFP_PAGE_05H, MSA_MODULE_CLASS, &value, 1);
1238   1              JUDGE_RETURN(ret);
1239   1              uart_printf("\r\n module_class:%bu",value);
1240   1              return ret;
1241   1      }
1242          
1243          uint8_t qsfp28_set_module_class(uint8_t value)
1244          {
1245   1              uint8_t ret = RET_FAILED;
1246   1      
1247   1              ret = smb_write_page_byte(I2C_DEVICE_ADDR,SFP_PAGE_05H, MSA_MODULE_CLASS, &value, 1);
1248   1              return ret;
1249   1      }
1250          
1251          uint8_t qsfp28_disable_module_poll()
1252          {
1253   1              uint8_t ret = RET_FAILED;
1254   1              uint16_t value = 0;
1255   1      
1256   1              ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, SFP_PAGE_04H);
1257   1              JUDGE_RETURN(ret);
1258   1              ret = i2c_master_read(I2C_DEVICE_ADDR,SFP_DDMI_ENABLE,(uint8_t *)&poll, 2);
1259   1              ret = i2c_master_write(I2C_DEVICE_ADDR,SFP_DDMI_ENABLE,(uint8_t *)&value, 0x2);
1260   1      
1261   1              return ret;
1262   1      }
1263          
1264          uint8_t qsfp28_enable_module_poll()
1265          {
C51 COMPILER V9.53.0.0   EFM8LB12_QSFP28                                                   10/14/2019 10:20:30 PAGE 22  

1266   1              uint8_t ret = RET_FAILED;
1267   1      
1268   1              ret = qsfp28_select_page(I2C_DEVICE_ADDR, SFP_PAGE_SELECT, SFP_PAGE_04H);
1269   1              JUDGE_RETURN(ret);
1270   1              ret = i2c_master_write(I2C_DEVICE_ADDR,SFP_DDMI_ENABLE, (uint8_t *)&poll, 0x2);
1271   1      
1272   1              return ret;
1273   1      }
1274          
1275          static uint8_t qsfp28_check_module_security_level(uint8_t page)
1276          {
1277   1              uint8_t ret = RET_OK, value = 0xCC;  //don't write value = 0xFE and 0xFF, because 0xFF indicate fail and 
             -0xFE indicate success
1278   1      
1279   1              if(page >= SFP_PAGE_04H && page < SFP_NONE_PAGE)
1280   1              {
1281   2                      i2c_master_write_byte(I2C_DEVICE_ADDR,SFP_PAGE_SELECT, SFP_PAGE_04H);
1282   2                      i2c_master_write(I2C_DEVICE_ADDR, SFP_MOD_SECUR_LEVEL_STATUS, (uint8_t *)&value, 0x1);
1283   2      
1284   2                      value = 0x0;
1285   2                      i2c_master_read(I2C_DEVICE_ADDR, SFP_MOD_SECUR_LEVEL_STATUS, (uint8_t *)&value, 0x1);
1286   2      
1287   2                      if(value == 0xCC)  //Write OK indicate enter security lever
1288   2                      {
1289   3                              ret = RET_OK;
1290   3                      }
1291   2                      else
1292   2                      {
1293   3                              ret = RET_NO_PERMISSION;
1294   3                      }
1295   2              }
1296   1      
1297   1              return ret;
1298   1      }
1299          
1300          uint8_t qsfp28_select_page(uint8_t BaseAddr,uint16_t OffsetAddr,uint8_t page)
1301          {
1302   1              uint8_t ret = RET_OK;
1303   1      
1304   1              ret = qsfp28_check_module_security_level(page);
1305   1              JUDGE_RETURN(ret);
1306   1              ret = i2c_master_write_byte(BaseAddr,OffsetAddr, page);
1307   1      
1308   1              return ret;
1309   1      }
1310          
1311          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8309    ----
   CONSTANT SIZE    =   1719    ----
   XDATA SIZE       =     81     421
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----      12
   BIT SIZE         =   ----       2
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
