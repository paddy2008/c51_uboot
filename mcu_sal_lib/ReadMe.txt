1、为什么要开发MCU_LIB库？
由于单片机实际开发过程中,硬件的配置总在改变,但是其中依然有不少纯软件的代码
例如串口通信,硬件只负责收发数据,软件需要对数据进行处理,例如字符的回显、字符
的删除、字符的增加、光标的移动、历史命令的记录等。如果这部分纯软件的处理与
串口硬件参杂在一起,那么基本上很难实现代码的重用,虽然这部分纯软件的逻辑并不
复杂,但是重新实现起来会增加开发周期,并且也不能保证重新实现的功能逻辑的正确性
;再例如硬件定时器的使用,由于硬件定时器资源有限,实际开发过程中,需要通过硬件定
时器扩展出软件定时器,同时实际开发的过程中也会有统计任务轮询一次的时间,都可以
通过软件定时器来实现,为此决定完全将硬件和软件的代码分开,将纯软件的代码独立成
库的形式,方便以后的移植和扩展,提高不同平台的开发效率。

2、实现的思想
(1)参考部分linux内核代码的实现,例如内核timer的实现,设置tick变量用于检测程序运行的周期
(2)参考STM32 HAL库的代码布局和编译结构

 说明：
 HAL库是一个整体,通过宏控制使用哪些库功能模块,MCU_LIB采用相同的处理思想,所以移植的时候,整体移植
 ,将整个库当做一个整体移植。
 
 (a)HAL库创建了一个stm32f1xx_hal_conf.h文件(对应本库中mcu_sal_hw_conf.h),该文件中定义了一些硬件相关的
 宏参数和每个功能库模块的宏开关,通过这个宏来控制是否使用相应的功能库模块,另外该文件中包含每个功能库模
 块的头文件。
 
 (b)HAL库创建一个stm32f1xx_hal.h文件(对应本库中mcu_sal.h),该文件包含了stm32f1xx_hal_conf.h文件,并创建对
 应的stm32f1xx_hal.c文件,该C文件主要是对纯软件功能库模块代码做初始化,即对整个库的运行环境做初始化,每个功能
 库模块的C文件只包含stm32f1xx_hal.h(mcu_sal.h)文件
 
 (c)HAL库创建一个stm32f1xx_hal_def.h文件(对应本库中mcu_sal_def.h),该文件只包含纯软件相关的宏设置,该文件被
 每个功能库模块的C文件包含,如此一来,外部应用程序只需要包含stm32f1xx_hal.h(mcu_sal.h)文件即可。


3、该库同时支持C51,STM32等单片机。

4、既然是库函数，那么库文件中不应该有开辟内存空间的动作。

5、由于库中管理相关功能模块的列表空间是通过宏控制的,例如ADC list, timer list
等等,考虑到单片机的硬件资源有限,这些管理链表并没有开辟很多的空间,所以实际开
发过程中,很有可能存在越界的可能,因为具体功能模块多少由应用环境而定,所以这些
宏控制会面临频繁改动的可能,而改动的结果可能就会导致内存越界的问题,因此库函数
中增加了相关log的调用,便于第一时间查看库函数的调用信息是否正确,这样一来,各个
功能模块库就相互交织在一起了,所以需要将这个库当做一个整体移植,如果没有使用到
的功能,也不会占用任何硬件资源的。

6、MCU_LIB库的实现中,有的是库函数调用硬件相关的接口,例如ADC功能模块,因为ADC的
   转换过程是硬件相关的,而为了尽量减小应用程序的改动,这个转换过程必须必须放到
   库函数中处理,所以必然会在库函数中调用硬件相关的接口,如果放到应用程序处理,就
   是硬件相关接口调用库函数，这样应用程序的处理逻辑就更麻烦了,不利于应用程序改
   动。再列举另外一个例子,PID模块,这个是硬件相关调用库函数,因为PID算法是纯软件
   逻辑,但是应用场景却不一样,有的是控制温度,有的是控制电机转速等, 这个根据应用
   场景而定，所以不能在库函数中调用硬件相关接口,而ADC功能模块是不一样的,不同的
   芯片,ADC都必须有这个转换过程,这对于不同平台都是相同的,只需要替换转换函数就
   可以了。
 

7、库文件的相关说明
   见对应的库文件中的说明


